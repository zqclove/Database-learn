# 第五章：创建高性能的索引

​	索引是存储引擎用于快速找到记录的一种数据结构，这是索引的基本功能，除此之外还有一些其他方面有用的属性。

​	索引对于良好的性能非常关键。表中数据量较小时，索引对性能的影响还不明显；表中数据量大时，不恰当的索引会导致性能急剧下降（这里指在传统硬盘的情况下。糟糕索引对于固态硬盘的影响没那么糟糕），最优的索引会将查询性能提高好几个数量级。

## 索引基础

​	在MySQL中，查询语句使用到索引时，先在索引中找到对应值，然后根据匹配的索引记录找到对于的数据行。假如要运行下面的查询：

```sql
SELECT frist_name FROM sakila.actor WHERE actor_id=5;
```

​	如果在actor_id列上建有索引，则MySQL将使用该索引找到actor_id为5的行，也就是说，MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行。

​	索引可以包含一个或多个列的值。MySQL使用最左前缀原则匹配索引，因此查询时条件中的列顺序和创建索引时的列顺序也十分重要。创建一个包含两个列的索引，与创建两个只包含一列的索引是大不相同的。

>**如果使用的是ORM，是否还需要关心索引？**
>
>简而言之：是的，仍然需要理解索引，即使是使用对象关系映射（ORM）工具。
>
>ORM工具能够产生符合逻辑、合法的查询（多数时候），除非只是生成非常基本的查询（例如仅是根据主键查询），否则它很难生成适合索引的查询。无论多么复杂的ORM工具，在精妙和复杂的索引前面都是“浮云”。请读完本章的内容后再研究该问题。

### 索引的类型

​	索引有许多类型，可以为不同的场景提供够好的性能。在MySQL中，索引是存储引擎层实现的，所以索引是没有同一标准的。不同存储引擎的索引工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一类型索引，其底层实现也可能不同。

#### B-Tree索引

​	***这里的 B-Tree 不是 B“减 ” Tree，而是 B "杠 " Tree***

​	B-Tree索引一种索引类型，并不是说B-Tree索引就是使用B-Tree这种数据结构实现的。不同存储引擎也可能使用不同的存储结构，例如，NDB集群存储引擎内部实际上使用了 T-Tree 结构存储这种索引，即使其名字是BTREE；InnoDB 则使用的是 B+Tree。（这里不探讨数据结构问题）

​	存储引擎以不同的方式使用B-Tree索引，性能也各不相同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但 InnoDB则按照元数据格式进行压缩。再如MyISAM索引通过数据的物理位置引用被索引的行，而 InnoDB则根据主键引用被索引的行。

​	B-Tree通常意味着**所有的值都是按顺序存储**的，并且**每个叶子节点到根的距离相同**。B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过**比较节点关键字的值和要查找的值可以找到合适的指针进入下层子节点**，这些**指针实际上定义了子节点关键字的值的上限和下限**。最后存储引擎要么找到对应的值，要么该记录不存在。

​	叶子节点比较特殊，它们的指针指向的是被索引的数据，而不是其他节点。**树的深度和表的大小直接相关**。

​	B-Tree对索引的列是顺序组织存储的，所以很适合查找范围数据。例如，在一个基于文本域的索引数上，按字母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以 A 到 K 开头的名字”这样的查找效率非常高。

​	假设有如下的数据表：

```sql
CREATE TABLE People (
	last_name  varchar(50)   not null,
	first_name varchar(50)   not null,
	dob 	   date          not null,
	gender     enum('m','f') not null,
	key(last_name,first_name,dob) --索引
);
```

​	索引对多个值进行排序的依据是定义索引时列的顺序。例如上面的数据表的索引，当last_name一样时，再根据first_name的顺序排序，以此类推。

​	**可以使用B-Tree索引的查询类型。**B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找[^注1]。前面所述的索引对如下类型的查询有效：

- **全值匹配**：

    ​	全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引（People表）可用于查找姓名为Cuba Allen、出生于1960-01-01的人。

- **匹配最左前缀**：

    ​	可以匹配**某一列的值**。例如前面提到的索引可用于查找所有姓为Allen 的人，即只是用索引的第一列。

- **匹配列前缀**：

    ​	也可以只匹配**某一列的值的开头部分**。例如前面提到的索引可用于查找所有以 K 开头的姓的人。这里只使用了索引的第一列。

- **匹配范围值**：

    ​	例如前面提到的索引可用于查找姓在 Allen 和 Barrymore 之间的人。这里也只使用了索引的第一列。因为MySQL的相关特性，只有当“前驱索引”是等值比较查询的情况下，当前索引才能范围查询（见后面B-Tree的限制）。

- **精确匹配某一列并范围匹配另外一列**：

    ​	前面提到的索引也可用于查找所有姓为 Allen，并且名字是字母 K 开头（如 Kim、Karl等）的人。即第一列last_name全匹配[^注2]，第二列frist_name范围匹配。

- **只访问索引的查询**：

    ​		B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。后面将单独讨论这种“覆盖索引”的优化。

[^注1]: 这是MySQL相关的特性，甚至和具体的版本也相关。其他有些数据库也可以使用索引的非前缀部分，虽然使用完全的前缀的效率会更好。
[^注2]: 因为B-Tree是按顺序存储的，所以当索引包含多个列时，先将第一列按顺序存储，然后在第一列相同值的情况下，再按第二列的顺序存储，以此类推。例如这里的例子，匹配到索引的第一列所有姓为Allen的人，然后在所有姓Allen的人中，又按照索引的第二列进行排序，这里是first_name列

​	因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的 ORDER BY 操作（按顺序查找）。一般来说，如果B-Tree可以按照某舟方式查找到值，那么也可以按照这种方式用于排序。所以如果    ORDER BY 子句满足前面列出的几种查询类型，则这个索引也可以满足对于的排序需求。

​	**下面是一些关于 B-Tree 索引的限制**：

​		***从左到右顺序找，中间断开左行右不行，范围索引放最后——对于索引列，不是查询语句的顺序***

- 如果不是按照索引的最左列开始查找，则无法使用索引。例如上面的例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人。因为这两个列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。
- 不能跳过索引中的列。也就是说，前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名（first_name），则MySQL只能使用索引的第一列（last_name）。
- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询 **WHERE last_name='Smith' AND first_name LIKE 'J%' AND dob='1976-12-23'**，这个查询只能使用索引的前两列，因为这里 LIKE 是一个范围条件（但是服务器可以把其余列用于其他目的）。如果范围查询列值的数量有限，那么可以通过使用多个等于条件代替范围条件。 

由此可见，索引列的顺序是十分重要的：这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。

也有些限制并不是B-Tree本身导致的，而是MySQL优化器和存储引擎使用索引方式导致的。

#### 哈希索引

​	哈希索引是基于哈希表实现的。要使用哈希索引查询数据，需要精确匹配所有索引列才有效。对于每一行的数据，存储引擎都会对所有索引列的值进行哈希计算，得出哈希表的“键（key）”，哈希表的“值（value）”则存放指向对应数据的指针。

​	总的来说，哈希索引将每行数据的索引列数据“拼凑”起来，计算出对于哈希码，该哈希码则代表该数据行。在MySQL中，只有Memory引擎显式支持哈希索引，Memory也支持**非唯一哈希索引**。使用非唯一哈希带来的问题就是哈希冲突，Memory存储引擎使用**链地址法**解决哈希冲突，在查询定位到对应哈希槽后，通过遍历链表和比较“值”得到数据行。

​	因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这样让哈希索引查找的速度非常快。但哈希索引也有一些限制：

- **哈希索引中只存放哈希值和指向数据行的指针**，因此不能像B-Tree索引那样直接从索引中读取数据行（覆盖索引）。不过，访问内存中的行的速度很快，大部分情况下这种限制不影响性能。
- **哈希索引对于的数据行不是按顺序存储的**，所以就无法用于排序。如果需要排序就无法使用哈希索引。
- **哈希索引不支持匹配部分索引列的查询**，从上面得知，哈希索引的“键（key）”是通过所有索引列计算出来的哈希码，因此如果使用部分索引列查询会得到错误结果。
- **哈希索引只支持等值比较的查询**，包括 =、IN()、<=>[^注3]。因为哈希一对一的存储结构与非顺序存储，所以不支持任何范围查询。
- **哈希冲突**。

​	InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用的非常频繁时，它就会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。这是InnoDB完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。

**自定义哈希索引**

​	如果存储引擎不支持哈希索引，用户可以自定义哈希索引。思路很简单：在B-Tree基础上创建一个伪哈希索引。这和真正的哈希索引不是一回事，因为还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引查找。你需要做的就是在查询的 WHERE 子句中手动指定使用哈希函数。

下面通过一个实例说明自定义哈希索引的需求：

​	假设在表中有一个列是用来存储 URL的，并且需要将该列作为B-Tree索引的索引列，如果URL过长，那么B-Tree存储的内容就会很大。此时我们可以使用自定义哈希索引来缩短存储内容，即删除原来的URL索引列，新增一个被索引的 url_crc列（同样表也要新增该字段），使用CRC32做哈希。两个方式的查询如下：

```sql
mysql> SELECT id FROM table WHERE url="http://www.mysql.com"; --使用URL列作索引列的查询

mysql> SELECT id FROM table WHERE url="http://www.mysql.com"
  	-> 	AND url_crc=CRC32("http://www.mysql.com");	--使用自定义哈希索引新增列作索引列的查询
```

​	这样做的性能会非常高，因为MySQL优化器会使用这个选择性很高而提交很小的基于url_crc列的索引来完成查找。如果是使用完整的URL字符串做索引，那样会非常慢。

​	这样实现的缺陷是需要维护哈希值。可以手动维护，也可以使用触发器实现。

[^注3]: <>与<=>是不同的操作。<=>  代表 ifNull( a != b，false)  。如果 a!=b 的结果为null，则最终结果为false，简单理解就是 对 “！=” 做了一个非空判断。

#### 空间数据索引（R-Tree）

​	MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效的使用任何维度来组合查询。**必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。**MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。开源关系数据库系统中对GIS的解决方案做的比较好的是PostgreSQL的PostGIS。

#### 全文索引

​	全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。

​	在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。

#### 其他索引类型

​	还有很多第三方的存储引擎使用不同类型的数据结构来存储索引。例如TokuDB使用分形树索引，这是一类较新开发的数据结构，既有B-Tree的很多有点，也避免了B-Tree的一些缺点。针对InnoDB的讨论也都适用于TokuDB。ScaleDB使用 Patricia tries（不是拼写错误），其他一些存储引擎技术如 InfiniDB和 Infobright则使用了一些特殊的数据结构来优化某些特殊的查询。	

## 索引的优点

​	索引最直观的优点是可以让服务器快速地定位到表的指定位置。根据创建索引的数据结构不同，索引也有一些其他的附加作用。

​	最常见的B-Tree索引，按照顺序存储，所以MySQL可以用来做 ORDER BY 和 GROUP BY操作。因为数据是有序的，所以B-Tree也会将相关的列值都存储在一起。B-Tree索引中的索引存储了实际的列值，所以某些查询只使用索引就能完成全部查询。

​	总结索引有如下三个有点：

- 索引大大减少了服务区需要扫描的数据量。
- 索引可以帮助服务器避免排序和临时表。
- 索引可以将随机 I/O 变为顺序 I/O。

**问题：索引是最好的解决方案吗？**

​	索引不总是最好的工具。因为维护索引等额外工作也是需要代价的，不是说索引对查询就一定是好的。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。

​	对于非常小的表，大部分情况下简单的全表扫描更加有效；对于中到大型的表，索引就非常有效；对于特大型的表，建立索引和使用索引的代价也随之增长，这种情况可以使用**分区技术**。如果表数量特别多，可以建立一个元数据信息表，用来查询需要用到某些特性。例如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于TB级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来代替索引。

## 高性能的索引策略

​	高性能查询的基础是正确地创建并使用索引。也就是说不正确的索引是会影响查询性能，而如何正确地创建和使用索引，是需要根据特定的场景进行判断的。下面介绍一些索引策略，是提高性能的常见策略。

### 独立的列

​	在查询的WHERE子句当中，如果需要使用索引，则索引列在表达式当中必须是独立的，否则MySQL就不会使用索引。总的来说，索引不能作为函数的参数或表达式的一部分。下面的SQL语句将无法使用索引：

```sql
SELECT col_name FROM table_name WHERE col_name+1=5; 
--索引列col_name是表达式col_name+1的一部分
或
SELECT ... WHERE TO_DAYS(CURRENT_DATE)-TO_DAYS(date_col)<=10;
--索引列date_col是函数的参数
```

### 前缀索引和索引选择性

​	**前缀索引**是指在很长的字符列（如BLOB、TEXT或很长的VARCHAR类型的列，这些类型的列是必须使用前缀索引，因为MySQL不允许索引这些列的完整长度）中，使用该字符串的前缀（索引值开始的部分字符）作为索引。

​	要使用前缀索引，需要了解索引选择性。因为选择性高的索引能够帮助MySQL在查找时过滤掉更多的行，因此查找性能也会变得更高。

​	**索引选择性**是指不重复的索引值（也称为基数）与数据表的记录总数（#T）的比值，范围为[1/#T，1]。选择性越高，说明值的唯一性越高，MySQL在查找时也就能够更快的找到对应的值。

​	使用前缀索引意味着重复项就会越多，也就导致了索引选择性的降低。因此在使用前缀索引时，我们应当选择合适的前缀字符个数，使索引选择性尽可能接近全字符时的索引选择性。下面展示如何选择合适的前缀字符个数。

​	下面参考《高性能MySQL：第三版》中的例子，在MySQL自带数据库World建立Country_demo数据表：

```SQL
CREATE TABLE World.country_demo(name VARCHAR(52) NOT NULL); --该表只含有name字段
--从World数据库中的country表中获取数据
INSERT INTO country_demo(name) SELECT name FROM country;
--重复下面的语句五次，增加数据量
INSERT INTO country_demo(name) SELECT name FROM country_demo;

--数据随机分布
UPDATE sakila.city_demo 
SET city=(SELECT city FROM sakila.city ORDER BY RAND() LIMIT 1);
```

首先，我们找到最常见的国家名：

```sql
mysql> SELECT COUNT(*) AS cnt,name 
	-> FROM country_demo GROUP BY name ORDER BY cnt DESC LIMIT10;
```

上面语句得出在country_demo表，国家名相同的行的前十：

![image-20201010145646128](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201010145646128.png)

然后，我们使用前缀进行查找，先使用3个前缀字母：

```sql
mysql> SELECT COUNT(*) AS cnt,LEFT(name,3) AS pref
    -> FROM country_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;
```

上面语句得出在country_demo表，国家名前三个字母相同的行的前十：

![image-20201010150255569](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201010150255569.png)

​	对比使用前缀（3个字符）和不适用前缀的结果，可以看出使用前缀重复项变得更多，索引选择性降低。

​	下面直接计算使用不同前缀个数和不使用前缀的索引选择性，通过比较结果分析使用多少个前缀字符是最适合的。

```sql
mysql> SELECT COUNT(DISTINCT LEFT(name,3))/COUNT(*) AS pre3,
    ->  COUNT(DISTINCT LEFT(name,7))/COUNT(*) AS pre7,
    ->  COUNT(DISTINCT LEFT(name,12))/COUNT(*) AS pre12,
    ->  COUNT(DISTINCT name)/COUNT(*) AS nopre
    -> FROM country_demo;
```

​	根据上面语句得到结果：

![image-20201010153525324](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201010153525324.png)

****

​	可以看到，前缀字符个数越多，索引选择性越接近无前缀索引。从上面的图中，我们可以发现前缀个数越多，索引选择性的提升幅度越小。所以前缀个数越多不一定是最好的选择，应当选择合适前缀个数和合适的索引选择性。从上面的结果中，我们可以选择pre7和pre12，但是这两个选择当中是有陷阱的，看如下分析。

​	pre7和pre12看似索引选择性十分接近，但是pre7的最常出现前缀的重复次数比无前缀最常国家名的次数要高出许多（在模拟数据可能相差不是很多，但真实案例的相差值会大很多）。如下所示，也能看到重复次数的分布是不均匀的，尽管pre7的索引选择性是接近无前缀时的索引前缀性，但考虑分布不均匀的情况该选择还不是最佳的。

```SQL
mysql> SELECT COUNT(*) AS cnt,LEFT(name,7) AS pref
    -> FROM country_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;
```

![image-20201010154042062](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201010154042062.png)

​	这次我们来看看pre12的重复次数。可以发现，pre12的分布比pre7更为均匀，就目前给出的前缀个数来选，pre12是其中的最佳选择。

```SQL
mysql> SELECT COUNT(*) AS cnt, LEFT(name,12) AS pref
    -> FROM country_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;
```

![image-20201011151533680](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201011151533680.png)

​	创建前缀索引（pre12）：

```sql
mysql> CREATE INDEX pre12_name ON country_demo(name(12));
mysql> show index from country_demo \G; --查看索引
```

​	**总结：**前缀索引的目的就是为了使索引变得更小、更快。更小体现在前缀字符的个数，更快体现在索引选择性的比值。在使用前缀索引时，应当根据索引选择性和重复数据分布情况来选择合适的前缀字符个数。

​	**前缀索引的缺点：**在MySQL当中，无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。

​	**使用前缀索引常见场景：**针对很长的十六进制唯一 ID使用前缀索引。在无法修改存储结构的情况下（例如基于MySQL的应用在存储网站的session时），可以在很长的十六进制字符串上创建索引。

### 多列索引

​	多列索引是指在建立索引时，联合多个列（字段）创建索引，又称联合索引。在B-Tree索引下，多列索引在创建时的索引列顺序是非常重要的，这关系到查询性能。良好的多列索引能够有效提高查询效率，不适当的多列索引可能会在查询语句中无法使用或没有提高查询性能。

​	对多列索引有一些误区，很多人认为多列索引是为每个列创建独立的索引，或按照错误的顺序创建多列索引。虽然在MySQL5.0和更新的版本中引入了一种叫“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。

​	使用EXPLAIN分析使用索引合并的查询语句的例子如下：

```SQL
mysql> CREATE TABLE index_test (
	actor_id INT(11) UNIQUE,
	film_id  INT(11) UNIQUE
); --创建有两个独立的唯一索引的表

EXPLAIN SELECT actor_id,film_id FROM index_test WHERE actor_id=1 OR film_id=1 \G;
```

执行EXPLAIN语句的结果如下：

![image-20201012110118372](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201012110118372.png)

​	在MySQL5.0和更新的版本中，查询能够使用多个单列索引进行扫描，并将结果进行合并。可以看到在 Extra 额外信息字段中，提示使用了两个索引扫描的联合。

​	MySQL会使用这类技术优化复杂查询，所以在某些语句的 Extra 列中还可以看到嵌套操作。

​	索引合并策略有时候是一种优化的结果，但实际更多时候说明了表上的索引建得非常糟糕：

- 当出现服务器对多个索引做相交操作时（通常是多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
- 当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要消耗大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
- 更重要的是，优化器不会把这些计算到“查询成本”（cost）中，**优化器只关心随机页面读取**。这会使得查询的成本被“低估”，导致该执行计划还不知道直接走全表扫描。这样做不但会消耗更多的CPU和内存资源，还可能会影响查询的并发性，但如果是单独运行这样的查询则往往会忽略对并发性的影响。通常来说，还不如像在MySQL4.1或更早的时代一样，将查询改写成UNION的方式往往更好。

如果在EXPLAIN中看到有索引合并，应该好好检查一下查询和表的结构，看是不是已经是最优的。也可以通过参数 **optimizer_switch** 来关闭索引合并功能。也可以使用 **IGNORE INDEX提示**让优化器忽略掉某些索引。

## 索引案例学习



## 维护索引和表





# 参考资料

高性能MySQL（第三版）— Baron Scbwartz，Peter Zaitsev，Vadim Tkacbenko（著）。主要以该文献为主编写该文章。

PS：该书以MySQL v5.5讲解

MySQL实战45讲 — 丁奇（著）。

