# 第五章：创建高性能的索引

​	索引是存储引擎用于快速找到记录的一种数据结构，这是索引的基本功能，除此之外还有一些其他方面有用的属性。

​	索引对于良好的性能非常关键。表中数据量较小时，索引对性能的影响还不明显；表中数据量大时，不恰当的索引会导致性能急剧下降（这里指在传统硬盘的情况下。糟糕索引对于固态硬盘的影响没那么糟糕），最优的索引会将查询性能提高好几个数量级。

## 索引基础

​	在MySQL中，查询语句使用到索引时，先在索引中找到对应值，然后根据匹配的索引记录找到对于的数据行。假如要运行下面的查询：

```sql
SELECT frist_name FROM sakila.actor WHERE actor_id=5;
```

​	如果在actor_id列上建有索引，则MySQL将使用该索引找到actor_id为5的行，也就是说，MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行。

​	索引可以包含一个或多个列的值。MySQL使用最左前缀原则匹配索引，因此查询时条件中的列顺序和创建索引时的列顺序也十分重要。创建一个包含两个列的索引，与创建两个只包含一列的索引是大不相同的。

>**如果使用的是ORM，是否还需要关心索引？**
>
>简而言之：是的，仍然需要理解索引，即使是使用对象关系映射（ORM）工具。
>
>ORM工具能够产生符合逻辑、合法的查询（多数时候），除非只是生成非常基本的查询（例如仅是根据主键查询），否则它很难生成适合索引的查询。无论多么复杂的ORM工具，在精妙和复杂的索引前面都是“浮云”。请读完本章的内容后再研究该问题。

### 索引的类型

​	索引有许多类型，可以为不同的场景提供够好的性能。在MySQL中，索引是存储引擎层实现的，所以索引是没有同一标准的。不同存储引擎的索引工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一类型索引，其底层实现也可能不同。

#### B-Tree索引

​	***个人觉得这里将 B-Tree索引换成 BTree索引更好，泛指使用 BTree类型的数据结构实现的索引***

​	B-Tree索引一种索引类型，并不是说B-Tree索引就是使用B-Tree这种数据结构实现的。不同存储引擎也可能使用不同的存储结构，例如，NDB集群存储引擎内部实际上使用了 T-Tree 结构存储这种索引，即使其名字是BTREE；InnoDB 则使用的是 B+Tree。（这里不探讨数据结构问题）

​	存储引擎以不同的方式使用B-Tree索引，性能也各不相同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但 InnoDB则按照元数据格式进行压缩。再如MyISAM索引通过数据的物理位置引用被索引的行，而 InnoDB则根据主键引用被索引的行。

​	B-Tree通常意味着**所有的值都是按顺序存**储的，并且**每个叶子节点到根的距离相同**。B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过**比较节点关键字的值和要查找的值可以找到合适的指针进入下层子节点**，这些**指针实际上定义了子节点关键字的值的上限和下限**。最后存储引擎要么找到对应的值，要么该记录不存在。

​	叶子节点比较特殊，它们的指针指向的是被索引的数据，而不是其他节点。**树的深度和表的大小直接相关**。

​	B-Tree对索引的列是顺序组织存储的，所以很适合查找范围数据。例如，在一个基于文本域的索引数上，按字母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以 A 到 K 开头的名字”这样的查找效率非常高。

​	假设有如下的数据表：

```sql
CREATE TABLE People (
	last_name  varchar(50)   not null,
	first_name varchar(50)   not null,
	dob 	   date          not null,
	gender     enum('m','f') not null,
	key(last_name,first_name,dob) --索引
);
```

​	索引对多个值进行排序的依据是定义索引时列的顺序。例如上面的数据表的索引，当last_name一样时，再根据first_name的顺序排序，以此类推。

​	**可以使用B-Tree索引的查询类型。**B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找[^注1]。前面所述的索引对如下类型的查询有效：

- **全值匹配**：

    ​	全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引（People表）可用于查找姓名为Cuba Allen、出生于1960-01-01的人。

- **匹配最左前缀**：

    ​	可以匹配**某一列的值**。例如前面提到的索引可用于查找所有姓为Allen 的人，即只是用索引的第一列。

- **匹配列前缀**：

    ​	也可以只匹配**某一列的值的开头部分**。例如前面提到的索引可用于查找所有以 K 开头的姓的人。这里只使用了索引的第一列。

- **匹配范围值**：

    ​	例如前面提到的索引可用于查找姓在 Allen 和 Barrymore 之间的人。这里也只使用了索引的第一列。

- **精确匹配某一列并范围匹配另外一列**：

    ​	前面提到的索引也可用于查找所有姓为 Allen，并且名字是字母 K 开头（如 Kim、Karl等）的人。即第一列last_name全匹配[^注2]，第二列frist_name范围匹配。

- **只访问索引的查询**：

    ​		B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。后面将单独讨论这种“覆盖索引”的优化。

[^注1]: 这是MySQL相关的特性，甚至和具体的版本也相关。其他有些数据库也可以使用索引的非前缀部分，虽然使用完全的前缀的效率会更好。
[^注2]: 因为B-Tree是按顺序存储的，所以当索引包含多个列时，先将第一列按顺序存储，然后在第一列相同值的情况下，再按第二列的顺序存储，以此类推。例如这里的例子，匹配到索引的第一列所有姓为Allen的人，然后在所有姓Allen的人中，又按照索引的第二列进行排序，这里是first_name列

​	因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的 ORDER BY 操作（按顺序查找）。一般来说，如果B-Tree可以按照某舟方式查找到值，那么也可以按照这种方式用于排序。所以如果    ORDER BY 子句满足前面列出的几种查询类型，则这个索引也可以满足对于的排序需求。

​	下面是一些关于 B-Tree 索引的限制：

- 如果不是按照索引的最左列开始查找，则无法使用索引。例如上面的例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人。因为这两个列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。
- 不能跳过索引中的列。也就是说，前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名（first_name），则MySQL只能使用索引的第一列（last_name）。
- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询 **WHERE last_name='Smith' AND first_name LIKE 'J%' AND dob='1976-12-23'**，这个查询只能使用索引的前两列，因为这里 LIKE 是一个范围条件（但是服务器可以把其余列用于其他目的）。如果范围查询列值的数量有限，那么可以通过使用多个等于条件代替范围条件。 

由此可见，索引列的顺序是十分重要的：这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。

也有些限制并不是B-Tree本身导致的，而是MySQL优化器和存储引擎使用索引方式导致的。

## 索引的优点



## 高性能的索引策略



## 索引案例学习



## 维护索引和表





# 参考资料

高性能MySQL（第三版）— Baron Scbwartz，Peter Zaitsev，Vadim Tkacbenko（著）。主要以该文献为主编写该文章。

PS：该书以MySQL v5.5讲解

MySQL实战45讲 — 丁奇（著）。

