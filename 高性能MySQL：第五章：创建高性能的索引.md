[TOC]



# 第五章：创建高性能的索引

​	索引是存储引擎用于快速找到记录的一种数据结构，这是索引的基本功能，除此之外还有一些其他方面有用的属性。

​	索引对于良好的性能非常关键。表中数据量较小时，索引对性能的影响还不明显；表中数据量大时，不恰当的索引会导致性能急剧下降（这里指在传统硬盘的情况下。糟糕索引对于固态硬盘的影响没那么糟糕），最优的索引会将查询性能提高好几个数量级。

## 索引基础

​	在MySQL中，查询语句使用到索引时，先在索引中找到对应值，然后根据匹配的索引记录找到对于的数据行。假如要运行下面的查询：

```sql
SELECT frist_name FROM sakila.actor WHERE actor_id=5;
```

​	如果在actor_id列上建有索引，则MySQL将使用该索引找到actor_id为5的行，也就是说，MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行。

​	索引可以包含一个或多个列的值。MySQL使用最左前缀原则匹配索引，因此查询时条件中的列顺序和创建索引时的列顺序也十分重要。创建一个包含两个列的索引，与创建两个只包含一列的索引是大不相同的。

>**如果使用的是ORM，是否还需要关心索引？**
>
>简而言之：是的，仍然需要理解索引，即使是使用对象关系映射（ORM）工具。
>
>ORM工具能够产生符合逻辑、合法的查询（多数时候），除非只是生成非常基本的查询（例如仅是根据主键查询），否则它很难生成适合索引的查询。无论多么复杂的ORM工具，在精妙和复杂的索引前面都是“浮云”。请读完本章的内容后再研究该问题。

### 索引的类型

​	索引有许多类型，可以为不同的场景提供够好的性能。在MySQL中，索引是存储引擎层实现的，所以索引是没有同一标准的。不同存储引擎的索引工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一类型索引，其底层实现也可能不同。

#### B-Tree索引

​	***这里的 B-Tree 不是 B“减 ” Tree，而是 B "杠 " Tree***

​	B-Tree索引一种索引类型，并不是说B-Tree索引就是使用B-Tree这种数据结构实现的。不同存储引擎也可能使用不同的存储结构，例如，NDB集群存储引擎内部实际上使用了 T-Tree 结构存储这种索引，即使其名字是BTREE；InnoDB 则使用的是 B+Tree。（这里不探讨数据结构问题）

​	存储引擎以不同的方式使用B-Tree索引，性能也各不相同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但 InnoDB则按照元数据格式进行压缩。再如MyISAM索引通过数据的物理位置引用被索引的行，而 InnoDB则根据主键引用被索引的行。

​	B-Tree通常意味着**所有的值都是按顺序存储**的，并且**每个叶子节点到根的距离相同**。B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过**比较节点关键字的值和要查找的值可以找到合适的指针进入下层子节点**，这些**指针实际上定义了子节点关键字的值的上限和下限**。最后存储引擎要么找到对应的值，要么该记录不存在。

​	叶子节点比较特殊，它们的指针指向的是被索引的数据，而不是其他节点。**树的深度和表的大小直接相关**。

​	B-Tree对索引的列是顺序组织存储的，所以很适合查找范围数据。例如，在一个基于文本域的索引数上，按字母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以 A 到 K 开头的名字”这样的查找效率非常高。

​	假设有如下的数据表：

```sql
CREATE TABLE People (
	last_name  varchar(50)   not null,
	first_name varchar(50)   not null,
	dob 	   date          not null,
	gender     enum('m','f') not null,
	key(last_name,first_name,dob) --索引
);
```

​	索引对多个值进行排序的依据是定义索引时列的顺序。例如上面的数据表的索引，当last_name一样时，再根据first_name的顺序排序，以此类推。

​	**可以使用B-Tree索引的查询类型。**B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找[^注1]。前面所述的索引对如下类型的查询有效：

- **全值匹配**：

    ​	全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引（People表）可用于查找姓名为Cuba Allen、出生于1960-01-01的人。

- **匹配最左前缀**：

    ​	可以匹配**某一列的值**。例如前面提到的索引可用于查找所有姓为Allen 的人，即只是用索引的第一列。

- **匹配列前缀**：

    ​	也可以只匹配**某一列的值的开头部分**。例如前面提到的索引可用于查找所有以 K 开头的姓的人。这里只使用了索引的第一列。

- **匹配范围值**：

    ​	例如前面提到的索引可用于查找姓在 Allen 和 Barrymore 之间的人。这里也只使用了索引的第一列。因为MySQL的相关特性，只有当“前驱索引”是等值比较查询的情况下，当前索引才能范围查询（见后面B-Tree的限制）。

- **精确匹配某一列并范围匹配另外一列**：

    ​	前面提到的索引也可用于查找所有姓为 Allen，并且名字是字母 K 开头（如 Kim、Karl等）的人。即第一列last_name全匹配[^注2]，第二列frist_name范围匹配。

- **只访问索引的查询**：

    ​		B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。后面将单独讨论这种“覆盖索引”的优化。

[^注1]: 这是MySQL相关的特性，甚至和具体的版本也相关。其他有些数据库也可以使用索引的非前缀部分，虽然使用完全的前缀的效率会更好。
[^注2]: 因为B-Tree是按顺序存储的，所以当索引包含多个列时，先将第一列按顺序存储，然后在第一列相同值的情况下，再按第二列的顺序存储，以此类推。例如这里的例子，匹配到索引的第一列所有姓为Allen的人，然后在所有姓Allen的人中，又按照索引的第二列进行排序，这里是first_name列

​	因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的 ORDER BY 操作（按顺序查找）。一般来说，如果B-Tree可以按照某舟方式查找到值，那么也可以按照这种方式用于排序。所以如果    ORDER BY 子句满足前面列出的几种查询类型，则这个索引也可以满足对于的排序需求。

​	**下面是一些关于 B-Tree 索引的限制**：

​		***从左到右顺序找，中间断开左行右不行，范围索引放最后——对于索引列，不是查询语句的顺序***

- 如果不是按照索引的最左列开始查找，则无法使用索引。例如上面的例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人。因为这两个列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。
- 不能跳过索引中的列。也就是说，前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名（first_name），则MySQL只能使用索引的第一列（last_name）。
- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询 **WHERE last_name='Smith' AND first_name LIKE 'J%' AND dob='1976-12-23'**，这个查询只能使用索引的前两列，因为这里 LIKE 是一个范围条件（但是服务器可以把其余列用于其他目的）。如果范围查询列值的数量有限，那么可以通过使用多个等于条件代替范围条件。 

由此可见，索引列的顺序是十分重要的：这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。

也有些限制并不是B-Tree本身导致的，而是MySQL优化器和存储引擎使用索引方式导致的。

#### 哈希索引

​	哈希索引是基于哈希表实现的。要使用哈希索引查询数据，需要精确匹配所有索引列才有效。对于每一行的数据，存储引擎都会对所有索引列的值进行哈希计算，得出哈希表的“键（key）”，哈希表的“值（value）”则存放指向对应数据的指针。

​	总的来说，哈希索引将每行数据的索引列数据“拼凑”起来，计算出对于哈希码，该哈希码则代表该数据行。在MySQL中，只有Memory引擎显式支持哈希索引，Memory也支持**非唯一哈希索引**。使用非唯一哈希带来的问题就是哈希冲突，Memory存储引擎使用**链地址法**解决哈希冲突，在查询定位到对应哈希槽后，通过遍历链表和比较“值”得到数据行。

​	因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这样让哈希索引查找的速度非常快。但哈希索引也有一些限制：

- **哈希索引中只存放哈希值和指向数据行的指针**，因此不能像B-Tree索引那样直接从索引中读取数据行（覆盖索引）。不过，访问内存中的行的速度很快，大部分情况下这种限制不影响性能。
- **哈希索引对于的数据行不是按顺序存储的**，所以就无法用于排序。如果需要排序就无法使用哈希索引。
- **哈希索引不支持匹配部分索引列的查询**，从上面得知，哈希索引的“键（key）”是通过所有索引列计算出来的哈希码，因此如果使用部分索引列查询会得到错误结果。
- **哈希索引只支持等值比较的查询**，包括 =、IN()、<=>[^注3]。因为哈希一对一的存储结构与非顺序存储，所以不支持任何范围查询。
- **哈希冲突**。

​	InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用的非常频繁时，它就会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。这是InnoDB完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。

**自定义哈希索引**

​	如果存储引擎不支持哈希索引，用户可以自定义哈希索引。思路很简单：在B-Tree基础上创建一个伪哈希索引。这和真正的哈希索引不是一回事，因为还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引查找。你需要做的就是在查询的 WHERE 子句中手动指定使用哈希函数。

下面通过一个实例说明自定义哈希索引的需求：

​	假设在表中有一个列是用来存储 URL的，并且需要将该列作为B-Tree索引的索引列，如果URL过长，那么B-Tree存储的内容就会很大。此时我们可以使用自定义哈希索引来缩短存储内容，即删除原来的URL索引列，新增一个被索引的 url_crc列（同样表也要新增该字段），使用CRC32做哈希。两个方式的查询如下：

```sql
mysql> SELECT id FROM table WHERE url="http://www.mysql.com"; --使用URL列作索引列的查询

mysql> SELECT id FROM table WHERE url="http://www.mysql.com"
  	-> 	AND url_crc=CRC32("http://www.mysql.com");	--使用自定义哈希索引新增列作索引列的查询
```

​	这样做的性能会非常高，因为MySQL优化器会使用这个选择性很高而提交很小的基于url_crc列的索引来完成查找。如果是使用完整的URL字符串做索引，那样会非常慢。

​	这样实现的缺陷是需要维护哈希值。可以手动维护，也可以使用触发器实现。

[^注3]: <>与<=>是不同的操作。<=>  代表 ifNull( a != b，false)  。如果 a!=b 的结果为null，则最终结果为false，简单理解就是 对 “！=” 做了一个非空判断。

#### 空间数据索引（R-Tree）

​	MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效的使用任何维度来组合查询。**必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。**MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。开源关系数据库系统中对GIS的解决方案做的比较好的是PostgreSQL的PostGIS。

#### 全文索引

​	全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。

​	在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。

#### 其他索引类型

​	还有很多第三方的存储引擎使用不同类型的数据结构来存储索引。例如TokuDB使用分形树索引，这是一类较新开发的数据结构，既有B-Tree的很多有点，也避免了B-Tree的一些缺点。针对InnoDB的讨论也都适用于TokuDB。ScaleDB使用 Patricia tries（不是拼写错误），其他一些存储引擎技术如 InfiniDB和 Infobright则使用了一些特殊的数据结构来优化某些特殊的查询。	

## 索引的优点

​	索引最直观的优点是可以让服务器快速地定位到表的指定位置。根据创建索引的数据结构不同，索引也有一些其他的附加作用。

​	最常见的B-Tree索引，按照顺序存储，所以MySQL可以用来做 ORDER BY 和 GROUP BY操作。因为数据是有序的，所以B-Tree也会将相关的列值都存储在一起。B-Tree索引中的索引存储了实际的列值，所以某些查询只使用索引就能完成全部查询。

​	总结索引有如下三个有点：

- 索引大大减少了服务区需要扫描的数据量。
- 索引可以帮助服务器避免排序和临时表。
- 索引可以将随机 I/O 变为顺序 I/O。

**问题：索引是最好的解决方案吗？**

​	索引不总是最好的工具。因为维护索引等额外工作也是需要代价的，不是说索引对查询就一定是好的。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。

​	对于非常小的表，大部分情况下简单的全表扫描更加有效；对于中到大型的表，索引就非常有效；对于特大型的表，建立索引和使用索引的代价也随之增长，这种情况可以使用**分区技术**。如果表数量特别多，可以建立一个元数据信息表，用来查询需要用到某些特性。例如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于TB级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来代替索引。

## 高性能的索引策略

​	高性能查询的基础是正确地创建并使用索引。也就是说不正确的索引是会影响查询性能，而如何正确地创建和使用索引，是需要根据特定的场景进行判断的。下面介绍一些索引策略，是提高性能的常见策略。

### 独立的列

​	在查询的WHERE子句当中，如果需要使用索引，则索引列在表达式当中必须是独立的，否则MySQL就不会使用索引。总的来说，索引不能作为函数的参数或表达式的一部分。下面的SQL语句将无法使用索引：

```sql
SELECT col_name FROM table_name WHERE col_name+1=5; 
--索引列col_name是表达式col_name+1的一部分
或
SELECT ... WHERE TO_DAYS(CURRENT_DATE)-TO_DAYS(date_col)<=10;
--索引列date_col是函数的参数
```

### 前缀索引和索引选择性

​	**前缀索引**是指在很长的字符列（如BLOB、TEXT或很长的VARCHAR类型的列，这些类型的列是必须使用前缀索引，因为MySQL不允许索引这些列的完整长度）中，使用该字符串的前缀（索引值开始的部分字符）作为索引。

​	要使用前缀索引，需要了解索引选择性。因为选择性高的索引能够帮助MySQL在查找时过滤掉更多的行，因此查找性能也会变得更高。

​	**索引选择性**是指不重复的索引值（也称为基数）与数据表的记录总数（#T）的比值，范围为[1/#T，1]。选择性越高，说明值的唯一性越高，MySQL在查找时也就能够更快的找到对应的值。

​	使用前缀索引意味着重复项就会越多，也就导致了索引选择性的降低。因此在使用前缀索引时，我们应当选择合适的前缀字符个数，使索引选择性尽可能接近全字符时的索引选择性。下面展示如何选择合适的前缀字符个数。

​	下面参考《高性能MySQL：第三版》中的例子，在MySQL自带数据库World建立Country_demo数据表：

```SQL
CREATE TABLE World.country_demo(name VARCHAR(52) NOT NULL); --该表只含有name字段
--从World数据库中的country表中获取数据
INSERT INTO country_demo(name) SELECT name FROM country;
--重复下面的语句五次，增加数据量
INSERT INTO country_demo(name) SELECT name FROM country_demo;

--数据随机分布
UPDATE sakila.city_demo 
SET city=(SELECT city FROM sakila.city ORDER BY RAND() LIMIT 1);
```

首先，我们找到最常见的国家名：

```sql
mysql> SELECT COUNT(*) AS cnt,name 
	-> FROM country_demo GROUP BY name ORDER BY cnt DESC LIMIT10;
```

上面语句得出在country_demo表，国家名相同的行的前十：

![image-20201010145646128](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201010145646128.png)

然后，我们使用前缀进行查找，先使用3个前缀字母：

```sql
mysql> SELECT COUNT(*) AS cnt,LEFT(name,3) AS pref
    -> FROM country_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;
```

上面语句得出在country_demo表，国家名前三个字母相同的行的前十：

![image-20201010150255569](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201010150255569.png)

​	对比使用前缀（3个字符）和不适用前缀的结果，可以看出使用前缀重复项变得更多，索引选择性降低。

​	下面直接计算使用不同前缀个数和不使用前缀的索引选择性，通过比较结果分析使用多少个前缀字符是最适合的。

```sql
mysql> SELECT COUNT(DISTINCT LEFT(name,3))/COUNT(*) AS pre3,
    ->  COUNT(DISTINCT LEFT(name,7))/COUNT(*) AS pre7,
    ->  COUNT(DISTINCT LEFT(name,12))/COUNT(*) AS pre12,
    ->  COUNT(DISTINCT name)/COUNT(*) AS nopre
    -> FROM country_demo;
```

​	根据上面语句得到结果：

![image-20201010153525324](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201010153525324.png)

****

​	可以看到，前缀字符个数越多，索引选择性越接近无前缀索引。从上面的图中，我们可以发现前缀个数越多，索引选择性的提升幅度越小。所以前缀个数越多不一定是最好的选择，应当选择合适前缀个数和合适的索引选择性。从上面的结果中，我们可以选择pre7和pre12，但是这两个选择当中是有陷阱的，看如下分析。

​	pre7和pre12看似索引选择性十分接近，但是pre7的最常出现前缀的重复次数比无前缀最常国家名的次数要高出许多（在模拟数据可能相差不是很多，但真实案例的相差值会大很多）。如下所示，也能看到重复次数的分布是不均匀的，尽管pre7的索引选择性是接近无前缀时的索引前缀性，但考虑分布不均匀的情况该选择还不是最佳的。

```SQL
mysql> SELECT COUNT(*) AS cnt,LEFT(name,7) AS pref
    -> FROM country_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;
```

![image-20201010154042062](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201010154042062.png)

​	这次我们来看看pre12的重复次数。可以发现，pre12的分布比pre7更为均匀，就目前给出的前缀个数来选，pre12是其中的最佳选择。

```SQL
mysql> SELECT COUNT(*) AS cnt, LEFT(name,12) AS pref
    -> FROM country_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;
```

![image-20201011151533680](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201011151533680.png)

​	创建前缀索引（pre12）：

```sql
mysql> CREATE INDEX pre12_name ON country_demo(name(12));
mysql> show index from country_demo \G; --查看索引
```

​	**总结：**前缀索引的目的就是为了使索引变得更小、更快。更小体现在前缀字符的个数，更快体现在索引选择性的比值。在使用前缀索引时，应当根据索引选择性和重复数据分布情况来选择合适的前缀字符个数。

​	**前缀索引的缺点：**在MySQL当中，无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。

​	**使用前缀索引常见场景：**针对很长的十六进制唯一 ID使用前缀索引。在无法修改存储结构的情况下（例如基于MySQL的应用在存储网站的session时），可以在很长的十六进制字符串上创建索引。

### 多列索引

​	多列索引是指在建立索引时，联合多个列（字段）创建索引，又称联合索引。在B-Tree索引下，多列索引在创建时的索引列顺序是非常重要的，这关系到查询性能。良好的多列索引能够有效提高查询效率，不适当的多列索引可能会在查询语句中无法使用或没有提高查询性能。

​	对多列索引有一些误区，很多人认为多列索引是为每个列创建独立的索引，或按照错误的顺序创建多列索引。虽然在MySQL5.0和更新的版本中引入了一种叫“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。

​	使用EXPLAIN分析使用索引合并的查询语句的例子如下：

```SQL
mysql> CREATE TABLE index_test (
	actor_id INT(11) UNIQUE,
	film_id  INT(11) UNIQUE
); --创建有两个独立的唯一索引的表

EXPLAIN SELECT actor_id,film_id FROM index_test WHERE actor_id=1 OR film_id=1 \G;
```

执行EXPLAIN语句的结果如下：

![image-20201012110118372](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201012110118372.png)

​	在MySQL5.0和更新的版本中，查询能够使用多个单列索引进行扫描，并将结果进行合并。可以看到在 Extra 额外信息字段中，提示使用了两个索引扫描的联合。

​	MySQL会使用这类技术优化复杂查询，所以在某些语句的 Extra 列中还可以看到嵌套操作。

​	索引合并策略有时候是一种优化的结果，但实际更多时候说明了表上的索引建得非常糟糕：

- 当出现服务器对多个索引做相交操作时（通常是多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
- 当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要消耗大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
- 更重要的是，优化器不会把这些计算到“查询成本”（cost）中，**优化器只关心随机页面读取**。这会使得查询的成本被“低估”，导致该执行计划还不知道直接走全表扫描。这样做不但会消耗更多的CPU和内存资源，还可能会影响查询的并发性，但如果是单独运行这样的查询则往往会忽略对并发性的影响。通常来说，还不如像在MySQL4.1或更早的时代一样，将查询改写成UNION的方式往往更好。

如果在EXPLAIN中看到有索引合并，应该好好检查一下查询和表的结构，看是不是已经是最优的。也可以通过参数 **optimizer_switch** 来关闭索引合并功能。也可以使用 **IGNORE INDEX提示**让优化器忽略掉某些索引。

### 合适的索引列顺序

​	该策略适用于 B-Tree索引，哈希索引或其他索引并不会像B-Tree索引一样按顺序存储数据。

​	该节主要讲的是定义索引列顺序的策略，在使用索引时的索引列顺序可以参考[B-Tree索引](#B-Tree索引)的有效查询和限制进行优化。

​	影响索引列顺序的因素：选择性、值分布，子句中的排序、分组和范围条件等。根据不同的场景选择合适的顺序。

​	选择索引列顺序有一个经验法则：将选择性最高的列放到索引最前列。该策略可能对一些场景有帮助，但如果需要排序和避免随机IO，那该策略则显得鸡肋。所以在不考虑排序和分组的情况下，该策略通常是最好的。

​	有一个非常典型的问题：某些应用或网站的特殊账号，如管理员或游客等。该特殊账号与正常用户的查询大不相同，因为特殊账号肯能有用大量的索引值，也就导致了值分布不均匀的情况。不止是这些特殊账号，那些拥有大量好友、图片、状态、收藏的用户，也会造成分布不均匀的情况。所以考虑选择性高的索引时，也需要考虑分布情况。

### 聚簇索引

​	聚簇索引又称为**索引组织表**，是一种数据存储方式，不是单独的索引类型。**具体细节依赖于其实现方式**，InnoDB的聚簇索引实际上在同一个结构中保存了 B-Tree索引和数据行（本文也主要讲解 InnoDB的聚簇索引）。

​	聚簇索引表示索引的叶子页中存放了数据行，意思是叶子索引和数据行聚在一起。一个表只能有一个聚簇索引，因为无法把数据行同时放在两个不同的地方。

​	聚簇索引需要是唯一并且非空的列作为索引列，一般 InnoDB会通过主键来聚集数据，但如果并未定义主键的表，通常会将第一个唯一非空的列作为聚集数据的列。如果表中并没有主键和唯一列，那么 InnoDB隐式定义一个字长为6字节的主键作为聚簇索引。总而言之，每一个表都会有一个聚簇索引来存放数据。

#### **聚集数据的优点**

- 可以把相关数据保存在一起。因为数据是聚集在一起的，当读取大量数据时，只需要从磁盘中读取少数的数据页就可以获取全部数据，减少磁盘I/O次数。如果没有聚簇索引，可能一行数据就需要一次磁盘I/O。
- 数据访问更快。因为聚簇索引将索引和数据保存在同一个B-Tree中，所以从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

通常在设计表和查询时充分利用上面的优点，就会极大的提升性能。

#### **聚簇索引的缺点**

- 将数据聚集在一起最大限度地提高了 I/O密集型应用的性能，但是如果数据全部存放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没什么优势了。
- 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 InnoDB表中速度最快的方式（非顺序插入可能会导致页分裂，从而影响速度）。如果不是按照主键顺序加载数据，那么在加载完成后最好使用 **OPTIMIZE TABLE**命令重新组织一下表。
- 更新聚簇索引的代价很高。因为会强制 InnoDB将每个被更新的数据行移动到新的位置。
- “页分裂（page split）”问题，使用聚簇索引的表在不按聚簇索引列的顺序插入新行，或主键被更新导致需要移动行的时候，就会产生页分裂。**页分裂产生条件**：向已满的数据页插入新的数据行。存储引擎为了存储新的数据行，会将原来存储在一个数据页的内容分别存储在两个数据页，移动数据会导致性能消耗，也会占用更多的磁盘空间。
- 聚簇索引可能导致全表扫描变慢，尤其是数据行比较稀疏，或者由于页分页导致数据存储不连续的时候。
- 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
- 使用二级索引查找数据需要两次索引查找。（自适应哈希索引能够减少这样的重复工作）

#### **InnoDB和MyISAM的数据分布对比**

​	InnoDB是将聚簇索引的叶子节点和数据行放在一起，非聚簇索引的叶子节点与主键值（聚簇索引列）放在一起。

​	MyISAM中不管是主键索引还是其他索引，在结构上没有什么不同，叶子节点都是存放指向存放数据的地址空间。这里存放数据的空间是按照数据插入的顺序存储在磁盘上（即线性表的顺序表示，一段连续的空间地址）。

##### ----------------------这里差一张图片说明---------------------------------

#### 在InnoDb按主键顺序插入数据行

​	如何选择聚簇索引，也会影响到查询性能。如果选择随机性的索引列作为聚簇索引，那么数据就没有任何聚集特性（虽然逻辑上是连续的，但物理上是不连续的）。随机性大的聚簇索引也会导致“页分裂”的情况。

​	一般来说，一个数据表最好选择一个按顺序插入数据行的索引列作为聚簇索引，如果表中没有这种列，可以定义一个代理键作为主键，该主键的数据与应用无关，最简单的方法是使用**AUTO_INCREMENT自增列**。这样做可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。



##### ---------这里有一个基准测试待写------------



> **顺序主键带来的问题：**
>
> 对于高并发工作负载，在 InnoDB中按主键顺序插入数据可能会导致更多的争用。因为插入的位置相同的可能性更高，所以并发插入可能导致间隙锁竞争。还有AUTO_INCREMENT锁机制问题。
>
> 如果遇到这个问题，可能需要考虑重新设计表或应用，或者更改`innodb_autoinc_lock_mode`配置。



### 覆盖索引

​	一个覆盖了所有所需查询字段的值的索引，称之为“覆盖索引”。MySQL可以通过索引来直接获取列的数据，而不需要再读取数据行。意思就是说如果二级索引的叶子节点已经包含了所要查询的数据，那么还有什么必要回表查询呢？

​	只需要扫描索引而无需回表查询的好处：

- 索引所占空间大小通常远小于数据行的大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量。只读取索引会减少磁盘IO次数，因此响应时间大部分就花在数据拷贝上，所以就对缓存的负载非常重要。覆盖索引对于I/O密集型应用也有帮助，因为索引比数据小，更容易全部放入内存中，对于MyISAM更是如此，因为MyISAM能够压缩索引以变得更小。
- 索引是按列值顺序存储的（至少在单个页内是如此），所以对于 I/O密集型的范围查询会比随机从磁盘读取每一行数据的 I/O次数要少得多。
- 对于一些在内存中只缓存索引的存储引擎而言（如MyISAM），覆盖索引大大提高性能。因为这些存储引擎的数据需要依赖操作系统来缓存，每次访问数据需要一次系统调用，这就可能导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。
- 因为 InnoDB的聚簇索引，覆盖索引对 InnoDB表特别有用。InnoDB的二级索引在叶子节点保存了行的主键值，所以如果二级索引能够覆盖查询，则可以避免对主键索引的二次查询。

​	在以上场景中，在索引中满足查询的成本一般比查询行数据要小多。

​	**覆盖索引必须要存储索引列的值**，因此不是所有类型的索引能可以成为覆盖索引，例如哈希索引、空间索引和全文索引等都不存储索引列的值，MySQL只能使用B-Tree索引做覆盖索引。需要注意的是，不同存储引擎实现覆盖索引的方式也不同，也不是所有存储引擎都支持覆盖索引。

​	使用`EXPLAIN`分析使用索引覆盖查询的语句，可以看到`Extra`列的值为 “Using index”，表示使用索引列的值。

**关于使用覆盖索引优化查询的问题：**

​	对于某些没有使用覆盖索引的查询，我们可以通过**延迟关联（deferred join）**的方式，将查询分为两个阶段或多个阶段，在子阶段的查询中使用覆盖索引，再通过使用覆盖索引查询的结果集，真正获取所需要的查询结果。即延迟了查询中真正需要的列的访问。

假设一张表 T，表中有索引列 col1以及其他列col2，...，coln，索引列名为 T_index1，有如下查询：

```mysql
mysql> SELECT * FROM T WHERE col1 = 10 and col2 like '%xxxx%';
```

使用`EXPLAIN`分析该查询，会发现没有使用索引覆盖查询中的列。

该查询有两个原因无法导致索引无法覆盖该查询：

- 没有任何索引能够覆盖所有列。该查询需要返回所有列的结果，没有索引与之对应（也不可取），因此无法使用覆盖索引查询结果。不过，理论上MySQL还有一个捷径可以利用：**WHERE条件中的列是有索引可以覆盖的**，因此MySQL可以使用该索引找到对应的”col1“并检查”col2“是否匹配，过滤之后再读取需要的数据行。
- 该查询中的`like`操作与最左前缀匹配相冲突，因此关于“col2”的索引就无法使用。

我们可以通过上述提到的延迟关联的方式重新设计查询，这里先将索引扩展至三个数据列（col1，col3，col2）：

```mysql
mysql> SELECT * 
	-> FROM T
	-> JOIN (
	->	 SELECT col3
	->	 FROM T
	->	 WHERE col1=10 AND col2 LIKE '%xxxx'
	-> ) AS t1 ON(t1.col3=T.col3);
```

​	使用`EXPLAIN`分析上面的查询，可以发现在子阶段的查询中是使用了索引覆盖的。在子阶段的查询中找到匹配的“col3”的结果集，然后根据这些结果集在外层查询匹配获取需要的所有列值。

​	但上述的优化效果取决于 WHERE条件匹配的行数。根据查询中条件对于的数据量不同，优化效果也不同。这里我们假设数据表“T"中有百万级数据量，看看不同的结果集对查询的优化效果：

- col1 列有万级数据量，col2 列也有万级数据量。在这样情况的查询中，子阶段返回的结果集是很大的，优化效果不明显，大部分时间都花在读取和发送数据上了。
- col1 列有万级数据量，col2 列几十行数据量。在这样情况的查询中，子阶段返回的结果集是很小的，优化效果非常明显，查询性能会提高数倍。因为只需要读取几十行的完整数据行，而不是col1列的万级数据量。
- col1 列有几十行数据量，col2 列也有几十行数据量。在这样情况的查询中，效率可能比原来的查询要下降。因为索引过滤时符合第一个条件的结果集已经很小，所以子查询带来的成本反而比从表中直接提取完整行更高。



> **关于索引条件下推（Index Condition Pushdown）：**
>
> 在MySQL5.6之前，比较字段的操作是由服务层进行的，每次找到的数据行都需要从存储引擎返回到服务层。所以每次二级索引的查找都需要进行“回表”。
>
> 在MySQL5.6之后，引入的索引条件下推，会将比较字段的操作放到存储引擎层进行，二级索引查找数据则无需“回表”找到数据行，直接根据列值判断。

### 使用索引扫描来做排序

​	MySQL有两种方式可以生成有序的结果：通过排序操作（file sort）和按索引顺序扫描。如果`EXPLAIN`出来的`type`列的值为“index”，则说明MySQL使用了索引扫描来做排序。

​	索引在`InnoDB`中，索引值是有序的（前缀列定值，后缀列有序），且可以通过指针直接访问下一条记录。在使用排序查询时，如果索引能够覆盖查询的列，就不需要回表查询对应的行，而是直接通过索引值顺序得出一个结果集；如果索引不能覆盖查询所需的所有列，那就不得不每扫描一条索引记录就回表查询一次对应的行，这样的操作基本是随机IO。因此按索引顺序读取数据的速度要比顺序地全表扫描慢（没用到覆盖索引），尤其是在 I/O密集型的工作负载时。

​	MySQL可以使用同一个索引在同一个语句中既满足排序，又用于查找。最好尽可能地设计这种满足两种任务的索引。

#### -----一些例子--------

问题：使用索引扫描必须要用到覆盖索引吗？



### 压缩索引

​	该方法适用于非B-Tree索引类型的。MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况能极大地提高性能。默认只压缩字符串，但通过参数设置也可以对整数做压缩。

​	MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。举个例子，索引块的第一个值是“perform”，第二个值是“performance”，那么第二个值的前缀压缩后存储的是类似“7，ance”这样的形式。MyISAM对行指针也采用类似的前缀压缩方式。

​	虽然压缩索引能够使用更少空间，使得更多索引放入内存中，但是压缩索引可能会导致某些操作变得更慢。因为每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在所以块使用二分查找而只能从头开始扫描。而从头扫描又意味着倒叙扫描（例如 `ORDER BY DESC`）就会速度下降。

​	是否使用压缩索引可以根据应用类型以及内存空间与磁盘空间之间的权衡做出选择。说到底，压缩索引主要在于“压缩”，是用于减少空间，对查询性能可能没有太大的提升（对某些应用还是有提升的）。

​	可以在 `CREATE TABLE`语句中指定`PACK_KEYS`参数来控制索引压缩的方式。

### 冗余和重复索引

​	**重复索引**是指在**相同的列**上按照**相同顺序**创建的**相同类型**的索引。在设计表和添加索引时，应该避免出现重复索引，发现后也应该立即移除。因为重复的索引意味着MySQL需要做的维护工作就更多，并且一些重复索引的维护工作是无意义的。

​	一个索引是已存在的**相同类型**的索引的**前缀索引**，则这个索引称为**冗余索引**。冗余索引与多列索引有关，例如已存在索引（A,B），如果再创建索引（A），则索引（A）就是冗余索引，因为只是前一个索引的**前缀索引**。因此索引（A,B）也可以当做索引（A）来使用（这种冗余只是对B-Tree索引来说的）。

​	冗余索引还有一种情况是联合索引中包含主键索引，例如索引（A，ID），其中ID是主键，对于 `InnoDB`来说主键列已经包含在二级索引中，所以这也是一种冗余情况。

​	大多数情况下冗余索引并没有什么意义，就如重复索引一般增加维护工作，应该尽量扩展已有的索引而不是创建新索引。但也有时候处于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。不同的查询也会需要不同的索引，一些查询可能单列索引会更快，一些查询可能联合索引会更快，所以索引在这种情况下还是会产生冗余。

​	解决冗余索引和重复索引很简单，就是删除这些索引即可。删除之前首先要找出这样的索引，而查找的方法请自学百度`Percona Toolkit`的*pt-duplicate-key-checker* 和 `Shlomi Noach`的*common_schema*。

​	删除冗余索引时需要注意上面提到关于主键冗余的情况，如果删除关于主键冗余的冗余索引，可能会导致在排序时会使用文件排序。例如已有索引（A），其实就相当于已有索引（A，ID），那么像 *WHERE A=5 ORDER BY ID*这样的查询就会用到索引排序。如果将索引扩展为索引（A，B），删除原来的冗余索引，那么上面的查询无法使用ID列做排序，而只能用文件排序了。

PS：无论是冗余还是重复，多出来的索引就需要更多时间去维护索引。因此`INSERT`、`UPDATE`、`DELETE`等操作时的速度就会变慢。

### 未使用的索引

​	索引与查询息息相关，索引是为了帮助查询提高查询速度。如果一些索引，永远不会被服务器使用，这样的索引建议删除。但还是有些未使用但用作唯一约束的索引（如`UNIQUE`修饰的列，用于避免重复数据），这些索引可以不删除。

​	有两种方法可以定位未使用的索引：

​	方法一（最简单有效的方法）：在`Percona Server`或者`MariaDB`中先打开`userstates`服务器变量，然后让服务器正常运行一段时间，再通过查询`INFORMATION_SCHEMA.INDEX_STATISTICS`就能查到每个索引的使用频率。

​	方法二：使用`Percona Toolkit` 中的*pt-index-usage*，该工具可以读取查询日志，并对日志中的每条查询进行`EXPLAIN`操作，然后打印出关于索引和查询的报告。这个工具不仅可以找出哪些索引是未使用的，还可以了解查询的执行计划——例如在某些情况有类似的查询的执行方式不一样，这可以帮助你定位到那些偶尔服务质量差的查询，优化它们以得到一致的性能表现。

### 索引和锁

​	索引可以让查询锁定更少的行。`InnoDB`的锁粒度主要是行级锁，只有在访问行的时候才会对其加锁，而索引就能够减少`InnoDB`访问的行数。

​	在MySQL未发布“索引条件下推”的版本前，索引无法根据`WHERE`子句的条件过滤不需要的行，只能将检索到数据返回给服务器层进行过滤，此时`InnoDB`就会锁住这些行。在可以使用“索引条件下推”的版本中，就可以在检索到数据后即刻根据条件过滤数据。

​	在MySQL5.6之后推出“索引条件下推（Index Condition Putdown，ICP）”，ICP主要针对二级索引的范围查询。开启和关闭ICP的语句如下（默认开启）：

```sql
SET optimizer_switch = 'index_condition_pushdown=off';
SET optimizer_switch = 'index_condition_pushdown=on';
```

------

​	根据《高性能MySQL》中P182中的例子，开启索引条件下推，发现如下问题：

​	有数据表rental：

```sql
CREATE TABLE rental (
    rental_id int PRIMARY KEY,
    rental_date DATE,
    inventory_id int,
    customer_id int,
    staff_id int,
    INDEX rental_date(rental_date,inventory_id,customer_id),
    INDEX (inventory_id),
    INDEX (customer_id),
    INDEX (staff_id)
); 
-- 数据有5行，除了rental_date外全都是1-5且每个列的值一样。
```

​	MySQL连接1的查询：

```sql
mysql>SET AUTOCOMMIT = 0;
mysql>BEGIN;
mysql>SELECT * FROM rental WHERE inventory_id < 5 AND inventory_id <> 1 FOR UPDATE;
```

​	MySQL连接2的查询：

```sql
mysql>SET AUTOCOMMIT = 0;
mysql>BEGIN;
mysql>SELECT * FROM rental WHERE inventory_id = 1 FOR UPDATE;
```

连接1执行结果：

![索引条件下推测试-查询连接1](C:\Users\Administrator\Desktop\学习\数据库\Database-learn\img\索引条件下推测试-查询连接1.png)

连接2执行结果：

![索引条件下推测试-查询连接2](C:\Users\Administrator\Desktop\学习\数据库\Database-learn\img\索引条件下推测试-查询连接2.png)

​	先执行连接1 的查询，再执行连接2的查询。根据运行情况，会发现连接2的查询会挂起，意味着 inventory_id = 1的行数据被锁定。

​	个人问题：开启索引条件下推后，`EXPLAIN`连接1的查询也发现`EXTRA`列的值是`using index condition`，那按照书本的意思连接1的查询应该不会锁住inventory_id=1的行数据，但测试发现被锁住了。

​	个人猜测：是否与间隙锁有关？

​	证明：在MySQL连接2中将条件修改，因为连接1有范围，会存在间隙锁，锁住inventory_id<5的间隙。连接2的查询修改为：

```sql
mysql>SET AUTOCOMMIT = 0;
mysql>BEGIN;
mysql>SELECT * FROM rental WHERE inventory_id = 7 FOR UPDATE;
-- 5 和 6 也被锁住
```

连接2修改后执行结果：

![索引条件下推测试-查询连接2（修改）](C:\Users\Administrator\Desktop\学习\数据库\Database-learn\img\索引条件下推测试-查询连接2（修改）.png)	

运行发现，连接2的查询并未被挂起，可以验证猜测思路正确，但并不百分百确定正确。

------



> ​	个人问题：索引条件下推是否无法连续使用？例如一个查询中有 *WHERE 范围条件1 AND 范围条件2*，都用到二级索引且是不同的二级索引，那么使用`EXPLAIN`会发现`EXTRA`列出现`using where`，是否意味着范围条件2并未使用索引条件下推？
>
> ​	个人猜想是范围条件二可能没走索引，就是索引条件下推还是需要遵循最左前缀原则。

​	关于`InnoDB`、索引和锁一些细节：`InnoDB`在二级索引上使用共享锁，但在访问主键索引需要排他锁。这消除了使用覆盖索引的可能性，并且使得`SELECT FOR UPDATE`比`LOCK IN SHARE MODE`或非锁定查询要慢很多。

## 索引案例学习



## 维护索引和表





# 参考资料

高性能MySQL（第三版）— Baron Scbwartz，Peter Zaitsev，Vadim Tkacbenko（著）。主要以该文献为主编写该文章。

PS：该书以MySQL v5.5讲解

MySQL实战45讲 — 丁奇（著）。

