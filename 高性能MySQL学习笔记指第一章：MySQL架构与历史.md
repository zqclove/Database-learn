# 参考文献

高性能MySQL（第三版）— Baron Scbwartz，Peter Zaitsev，Vadim Tkacbenko（著）。主要以该文献为主编写该文章。

PS：该书以MySQL v5.5讲解

MySQL实战45讲 — 丁奇（著）。

# 第一章：MySQL架构与历史

## MySQL逻辑架构

一条SQL查询语句是如何执行的。

### 架构逻辑图

![img](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)

​	大体而言，MySQL可以分为**Server层**和**存储引擎层**两部分。也有部分书籍将连接器单独分为一层，在此我们约定连接器也属于Server层。

​	**Server层**主要包括连接器、查询缓存、分析器、优化器、执行器等。大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（如日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

​	**存储引擎层**负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory等多个存储引擎。MySQL默认引擎是 InnoDB。

​	每个存储引擎都有它的优劣势，使用哪种存储引擎取决于业务场景的需求。服务层通过API的方式与存储引擎进行通信，这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一个记录”等操作。但存储引擎不会去解析SQL（InnoDB除外，它会解析外键定义，因为MySQL服务层没有实现该功能），不同存储引擎也不会相互通信，只是简单地响应上层的请求。

### 连接器

​	客户端在数据库查询数据之前都需要与MySQL服务器建立连接，这个建立连接是由连接器完成的。连接器负责跟客户端建立连接、获取权限、维持和管理连接。完成经典的TCP握手后，MySQL服务器会在其进程当中创建一个线程，这个链接的查询只会在这个线程中执行。

​	当客户端连接到MySQL服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。一旦客户端连接成功，连接器会到权限列表中查出该客户端的权限，之后这个连接的权限判断逻辑都基于此时读到的权限，即使管理员对该用户的权限进行了修改，也不会影响已经存在连接的权限。

​	连接完成后，如果客户端太长时间处于sleep状态，连接器会自动将其断开连接。该时间有参数**wait_timeout**控制，默认是8小时。超时之后，客户端在此发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。

![mysql连接超时参数](C:\Users\Administrator\Desktop\截图\mysql连接超时参数.PNG)

#### 长连接和短连接	

​	在数据库里面，长连接是指客户端在建立连接后，持续有请求，则一直使用同一连接。短连接则是指客户端在么次执行很少查询之后就断开连接，下次查询再创建连接。两个概念是相对而言的，不是指时间上的长短，而是指请求的长短。

​	连接器在建立连接的过程通常是比较复杂的，所以通常是使用长连接，减少连接器的压力。但随之而来的问题是，如果全部使用长连接，那么MySQL进程占用内存可能会涨得飞快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象中的。所以如果长连接积累下来，可能会导致内存过大，产生OOM的问题被系统强行杀掉，MySQL进程因此异常重启。

​	对于上面问题的解决方案有两种：

1. **定期断开长连接。**使用一段时间或者是程序里面判断执行过一个占用内存过大的查询后断开连接，之后查询再连接。
2. 该方案基于MySQL 5.7或更新版本，可以在每次执行较大的操作后，执行**mysql_reset_connection**命令来初始化连接资源。这个过程不需要重新连接和检查权限，但会将连接恢复到刚刚创建完成的状态。

### 查询缓存

​	MySQL在获取一个查询请求后，会先到缓存中查看是否之前执行过该语句。之前执行过的语句及结果会以键值对的形式被直接缓存到内存中。key是查询语句，value是查询结果。如果命中缓存则直接返回结果，未命中的继续后面的执行阶段。执行完成后，则会将执行结果存入查询缓存中。

​	查询缓存虽然能够提高查询效率，但同样也会带来各种问题。试想一下，缓存中的结果集是与一个表相关的，如果对一个表进行更新后，那么该缓存中的结果集会当成垃圾清空。这就使得查询缓存的失效可能性非常高，除非使用的是静态表，很长一段时间才更新，如系统配置表。甚至对于一些更新压力大的数据库而言，查询缓存的命中率非常低下。

​	在MySQL中，可以将参数 **query_cache_type** 设置成 **demand**，这样对于默认的SQL语句将不执行查询缓存。而对于确定要使用查询缓存的语句，可以用 **SQL_CACHE** 显式指定，如：

```mysql
mysql> select SQL_CACHE * from T where ID=10；
```

需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。

### 分析器

​	查询未命中缓存后，就真正开始执行语句了。MySQL为了知道查询请求需要做什么，需要对SQL语句进行解析，并创建内部数据结构（解析树）。

​	分析器首先进行**词法分析**，识别SQL语句中的关键字和语句中的字符串分别代表什么。之后进行**语法分析**，根据词法分析的结果和语法规则，判断该SQL语句是否满足MySQL语法。出错的会提示错误信息。一般语法错误会提示第一个出现错误的位置。

### 优化器

​	经过分析器后，MySQL知道该查询语句需要做什么，在执行该语句之前，还会进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。因为一条语句可能存在多种执行方案，不同的执行方案会有不同的执行效率，优化器的作用就是决定选择哪种方案。

​	用户可以通过特殊的关键字提示（hint）优化器，影响它的决策过程。也可以请求优化解释（explain）优化过程的各个因素，使用户知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置，使应用尽可能高效运行。后面的章节会讲到更多优化器的细节。

​	优化器并不关心使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。例如某些存储引擎的某种索引，可能对一些特定的查询有优化（索引的实现不同：hash结构与b+树）。

### 执行器

​	MySQL通过分析器知道要做什么，通过优化器知道要怎么做，于是进入到执行器，开始执行语句。

​	开始执行的时候，会先判断用户对于该语句中涉及权限的内容是否有权限，如是否允许用户对world数据库中的Country表执行SELECT语句。

​	如果没有权限，则会返回错误提示信息。值得一提的是，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限。

​	如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表定义存储引擎，去使用这个存储引擎提供的接口。

```mysql
mysql> select * from T where ID=10;
```

​	例如在上面这个例子中，表T的ID字段没有索引，那么执行器的执行流程如下：

1. 调用 **InnoDB** 引擎接口取这个表的第一行，判断ID是不是10，如果不是则跳过，如果是则将该行存在结果集中；

2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行（没有索引时的全表查询）；

3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

    至此，这个语句就执行完成了。

​	对于有索引的表，执行的逻辑差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是存储引擎中定义好的。

​	你会在数据库的慢查询日志中看到一个 **rows_examined** （调用次数）的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

​	在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此**引擎扫描行数跟 rows_examined 并不是完全相同的**。后面会专门有一篇章节来讲存储引擎的内部机制，里面会有详细的说明。

## 并发控制

​	只要多个查询请求在同一时刻修改数据，就会产生并发控制的问题。本小节探讨在MySQL两个层面的并发控制：服务层和存储引擎层。

### 读写锁

​	读取数据不会对数据产生变更，即使多个用户并发读取也不会产生什么问题。但是如果有用户正在修改数据信息，那读取数据的用户可能会报错退出，也可能读到不一致的数据。

​	解决读写问题的方法是并发控制。在处理并发读或写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁分别为**共享锁**（**读锁**）和**排他锁**（**写锁**）。

​	读锁是共享的，用户在读取数据互不阻塞，可以在同一时刻读取同一个资源。写锁是排他的，它会阻塞其他写锁和读锁，因为在用户修改某个资源时，不允许其他用户对该资源操作，只有这样才能保证在某一时刻只有一个用户执行写操作。

​	写锁的优先级比读锁高，因此一个写锁请求可能会被插入到读锁队列前面，而读锁不能插到写锁的前面。

### 锁粒度

​	并发问题使用锁解决，而锁的粒度又会影响并发量。例如，某个用户对表的部分资源进行写操作，但是却对整张表进行了锁定，这就导致其他用户无法访问该表中未进行写操作的部分资源，影响了并发性。因此，理想的方式是只对修改的数据进行精确锁定，锁定的数据量越少，并发量就越高。

​	锁定数据量越少，说明加锁的可能性就越大。而加锁也是需要消耗资源，锁的各种操作，包括获取锁、检查锁是否已经解除、释放锁等，等会增加系统的开销。如果系统花大量时间管理锁，而不是存取数据，那么系统的性能可能会因此收到影响。

​	所以在使用哪种锁策略时，应该在锁的开销和数据的安全性之间寻求平衡，这种平衡会影响到性能。MySQL提供了多种选择，每种存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是个非常重要的决定。将锁粒度固定到某个级别，可以为某些特定的应用场景提供更好的性能，但也失去了对另外的一些应用场景的良好支持。

### 锁策略

#### 表锁（table lock）

​	表锁是MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，都需要先获得写锁，这会阻塞其他用户对该表的读写操作。

​	在特定场景中，表锁也可能有良好的性能。例如，READ LOCAL表锁支持某些类型的并发操作。

​	尽管存储引擎可以管理自己的锁，但MySQL本身还是会使用各种有效的 **表锁** 来实现不同的目的。例如，服务层会为诸如 **ALTER TABLE** 之类的语句使用表锁，而忽略存储引擎的锁机制。

#### 行级锁（row lock）

​	行级锁最大程度地支持并发处理，同时也带了最大的锁开销。在 **InnoDB** 和 **XtraDB**，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而MySQL服务层没有实现。服务层完全不了解存储引擎中的锁实现。

## 事务

​	在MySQL中，事务支持是在存储引擎层实现的，但并不是所有存储引擎都实现事务。	

​	在MySQL中，可以使用 **START TRANSACTION** 语句开始一个事务，然后要么使用 **COMMIT** 提交事务将修改的数据持久保留，要么使用 **ROLLBACK** 回滚事务，撤销所有的修改。如下：

```mysql
START TRANSACTION;
SELECT balance FROM checking WHERE customer_id = 10233276;
UPDATE checking SET balance = balance - 200 WHERE customer_id = 10233276;
UPDATE savings SET balance = balance + 200 WHERE customer_id = 10233276;
COMMIT;
```

一个运行良好的事务处理系统，必须具备ACID的特性：

**原子性(atomicity):**

​	一个事务必须被视为不可分割的最小工作单元，整个事务中的操作要么全部成功，要么全部失败回滚。对于一个事物来说，不可能只执行其中的一部分，这就是事务的原子性。

**一致性(consistency)：**

​	数据库总是从一个一致性的状态转换到另外一个一致性的状态。在前面开始事务的例子中，一致性得到确保，即使在执行第3句和第4句之间时系统崩溃了，支票账户也不会损失200元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。

**隔离性(isolation):**

​	通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。同样以上面的例子为例，当执行完第3条语句、第4条还未开始时，此时有另外一个账户汇总程序开始运行，则其看到的支票账户的余额并没有被减去200元。值得一提的是，在 **读未提交** 的隔离级别的情况下，其他事务是可以读取到未提交的数据。

**持久性(durability):**

​	一旦事务提交，则其所做的修改就会永久保存到数据库中。持久性是个有点模糊的概念，因为实际上持久性也分很多不同级别。有些持久策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到100%的持久性保证的策略（如果数据库本身能够做到真正的持久性，那么备份又怎么能做到增加持久性呢？）。	



​	就像锁粒度的升级会增加系统开销一样。这种事务处理过程中额外的安全性，也会需要数据库系统做更多的工作。一个实现了ACID的数据库，相比没有实现ACID的数据库，通常会需要更强的CPU处理能力、更大的内存和更多的磁盘空间。这也正是MySQL的存储引擎架构可以发挥优势的地方。用户可以根据业务是否需要事务处理，来选择更合适的引擎。对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。例如对某张表只进行读操作，那么该表可以修改为非事务型存储引擎。即使一些存储引擎不支持事务，也可以通过 **LOCK TABLES** 语句为应用提供一定程度的保护。

### 隔离级别

​	在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离事务可以执行更高的并发，系统的开销也更低。

​	*每种存储引擎的隔离级别不尽相同。*

**READ UNCOMMITTED(读未提交):**

​	在该级别中，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被成为**脏读（dirty read）** 。这个级别会导致很多问题，从性能上来说，该级别不会比其他级别好太多，但却缺乏其他级别很多的好处，除非特殊需求，一般很少使用。

**READ COMMITTED(读已提交):**

​	大多数据库系统的默认级别都是该级别。该级别满足事务隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始到提交之前，所做的修改对其他事务是不可见的。这个级别有时候也叫作 **不可重复读**，因为执行两次同样的查询，可能会得到不一样的结果。

**REPEATABLE READ(可重复读):**

​	该级别是 **InnoDB** 的默认事务隔离界别。该级别保证了一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。解决了 **脏读** 和 **不可重复读** 的问题。但是理论上，该级别还是无法解决**幻读** 的问题（**幻读**：指的是当某个事务在读取某个范围的记录时，另一个事务又在该范围内插入新的记录，当之前的事务再次读取该范围的记录时，会产生幻行）。**InnoDB** 和 **XtraDB** 存储引擎通过 **MVCC(MultiVersion Concurrency Control，多版本控制)** 解决了幻读的问题。

​	该级别可能会与 **RC** 相混淆。两者区别在于事务启动后，对于其他事物所做的修改是否有反应。在 **RC** 中，当前事务可以读到其他事务提交后的数据，如果其他事物的修改涉及了本事务之前读取到的数据，那么就会发生 **不可重复读** 的问题。在 **RR** 中，每个事务在启动时，会生成一个快照，事务的执行过程看到的数据只与该快照相关，对于其他事务修改的数据一律“看不见”处理。

**SERIALIZABLE(可串行化):**

​	该级别是最高的隔离级别。它通过强制事务串行执行，避免了前面说的 **幻读** 问题。简单来说，该级别会在读写的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。

| 隔离级别                   | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| -------------------------- | ---------- | ---------------- | ---------- | ------ |
| READ UNCOMMITTED(读未提交) | YES        | YES              | YES        | NO     |
| READ COMMMITTED(读已提交)  | NO         | YES              | YES        | NO     |
| REPEATABLE READ(可重复读)  | NO         | NO               | YES        | NO     |
| SERIALIZABLE(串行化)       | NO         | NO               | NO         | YES    |

**参考丁奇MySQL实战中的例子：**

假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。

```mysql
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

![img](https://static001.geekbang.org/resource/image/7d/f8/7dea45932a6b722eb069d2264d0066f8.png)

​	我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。

- 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
- 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
- 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。



​	在实现上，数据库里面会创建一个视图，**访问的时候以视图的逻辑结果为准**。在 **可重复读** 隔离级别下，**这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。**在 **读提交** 隔离级别下，**这个视图是在每个 SQL  语句开始执行的时候创建的。**这里需要注意的是，**读未提交** 隔离级别下直接返回记录上的最新值，没有视图概念；而 **串行化** 隔离级别下直接用加锁的方式来避免并行访问。

​	**查看当前隔离级别的方式：**

```mysql
show variables like 'transaction_isolation'; // 1
select @@transaction_isolation; // 2
// 1 和 2 都可以
```

​	**修改当前session隔离级别的方式：**

```mysql
set session transaction isolation level (该处填隔离级别名) // 修改当前session的事务隔离级别
```

​	修改MySQL默认隔离级别可以在配置文件中修改。

#### 事务隔离的实现

​	*源自丁奇MySQL45讲*

​	这里展开说明 **RR** 级别的实现。

​	在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

​	假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

![img](https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png)

​	当前值是  4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是  1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到  1，就必须将当前值依次执行图中所有的回滚操作得到。

​	同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view  A、B、C  对应的事务是不会冲突的。

​	你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。

​	什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view  的时候。

​	基于上面的说明，我们来讨论一下为什么**建议你尽量不要使用长事务**。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

​	在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata  文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB  的库。最终只好为了清理回滚段，重建整个库。

​	除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。

#### MySQL中的事务

​	MySQL提供了两种事务型的存储引擎： **InnoDB** 和 **NDB Cluster**。另外还有一些第三方存储引擎也支持事务。

##### 自动提交(AUTOCOMMIT)

​	MySQL默认采用自动提交模式。也就是说，如果不显式的开始一个事务，则每个查询都被当做一个事务处理。在当前连接中，可以通过设置 **AUTOCOMMIT** 变量来启动或者禁用自动提交模式：

![MySQL中的自动提交模式](C:\Users\Administrator\Desktop\截图\MySQL中的自动提交模式.PNG)

1或者ON表示启用，0或者OFF表示禁用。在禁用模式中，所有的查询都是一个事务，直到显式地执行 **COMMIT** 或者 **ROLLBACK** 回滚，该事务才结束，同时开始另一个新事务。

​	对于使用非事务型数据库的表来说，修改自动提交模式不会有任何影响，因为对于这类表来说，没有 **COMMIT** 和 **ROLLBACK** 的概念，相当于一直处于自动提交模式。

​	另外有一些命令，在执行之前会 **强制执行** **COIMMIT** 提交当前的活动吧事务。例如，在数据定义语言（DDL）中，如果是会导致大量数据改变的操作，比如 **ALTER TABLE** 就是如此。还有 **LOCK TABLES** 等语句也会导致同样的结果。

#### 事务中混合使用存储引擎

​	我们知道，MySQL服务层不管理事务，事务是由存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。

​	如果在事务中混合使用事务型和非事务型的表，正常提交不会有什么问题。但是如果该事物需要回滚，非事务型的表上的变更将无法撤销，就会导致数据库处于不一致的状态。

#### 显式锁定和隐式锁定

​	**InnoDB** 采用的是 **两阶段锁定协议** 。在事务执行过程中，随时可以进行锁定，锁只有在 **COMMIT** 或 **ROLLBACK** 时才会释放，并且所有的锁同一时刻释放。这里的锁定指的是隐式锁定， **InnoDB** 会根据隔离级别在需要的时候自动加锁。

​	显式锁定则通过特定的语句加锁（这些语句不属于SQL规范）：

```mysql
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
```

​	MySQL服务层还实现了 **LOCK TABLES** 和 **UNLOCK TABLES** 语句，和存储引擎无关。

​	***建议：LOCK TABLES 和事物之间相互影响的话，情况会变得非常复杂，在某些MySQL版本中甚至会发生无法预测的结果。因此，建议除了事务中禁用了 AUTOCOMMIT模式情况下可以使用 LOCK TABLES之外，其他任何时候都不要显式执行 LOCK TABLES，不管何种存储引擎。*** 

## 多版本并发控制(MVCC)

​	MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提高并发性能的考虑，他们一般都同时实现了多版本并发控制。

​	MVCC可以认为是行级锁的一个变种，它在很多情况下避免了加锁，因此开销更低。虽然实现机制有所不同（MVCC没有统一规范，不同数据库实现不同），但大都实现了非阻塞的读操作，写操作也之锁定必要的行。所以被称为行级锁的变种。

​	MVCC的实现，是通过保存数据在某个时间点的快照来实现的。不管需要执行多长时间，保证了每个事务看到的数据都是一致的（参考 **RR** 级别）。因为事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样。

​	MVCC的实现大概可以分为 **乐观并发控制** 和 **悲观并发控制**。下面通过 **InnoDB** 的简化版行为说明MVCC如何工作。

​	**InnoDB** 的 MVCC，是**通过在每行记录后面保存两个隐藏的列实现的**。这两个列分别是 **行的创建时间** 和 **行的过期时间（或删除时间）。** 保存的并不是真正的时间，而是 **系统版本号**。**系统版本号会在开始一个事务是自增，事务开始时刻的版本号会作为事务的版本号，用来和查询到的每行记录进行比较。** 

​	下面展示在 **RR** 隔离级别下，MVCC具体是如何操作的：

- **SELECT:**

    InnoDB 会根据以下两个条件检查每行记录：

    1. InnoDB 只查找版本号 **早于（小于或等于）** 当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已存在，要么是事务自身插入或者修改过的。
    2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

    只有符合上述两个条件的记录，才能返回作为查询结果。

- **INSERT:**

    InnoDB 为新插入的每一行保存 **当前系统版本号** 作为行版本号。

- **DELETE:**

    InnoDB 为删除的每一行保存 **当前系统版本号** 作为行删除标识。

- **UPDATE:**

    InnoDB 为插入一行新记录，保存 **当前系统版本号** 作为行版本号。同时保存 **当前系统版本号** 到原来的行作为行删除标识。

    

    ​	保存这两个额外的系统版本号，使大多数读操作都可以不用加锁。这样设计使得读操作简单，性能好，并且也能保证只会读到符号标准的行。不足之处是每行记录都需要额外的空间，需要做更多的行检查工作，以及一些额外的维护工作。

    ​	MVCC 只在 **RR** 和 **RC** 两个隔离级别下工作（MySQL 5.5）。因为 **RU** 总是读取最新的数据行，**S** 则会对所有读取的行都加锁。

##  MySQL的存储引擎

​	在文件系统中，MySQL将每个数据库（也可以称之为 schema）保存为**数据目录(%datadir%)**下的一个子目录。

![mysql存放数据库的目录](C:\Users\Administrator\Desktop\截图\mysql存放数据库的目录.PNG)

​	创建表时，MySQL会在数据库子目录下创建一个和表同名的 **.frm** 文件保存**表的定义**（在win7中MySQL 8.0版本后缀名为 **.ibd**）。

![mysql 数据库中的表在文件系统中的后缀名](C:\Users\Administrator\Desktop\截图\mysql 数据库中的表在文件系统中的后缀名.PNG)

​	因为MySQL使用文件系统的目录和文件来保存数据库和表的定义，因此大小写敏感性和具体的平台密切相关。在Windows中，大小不敏感；而在类Unix中则是敏感的。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在MySQL服务层统一处理的。

​	可以使用 **SHOW TABLE STATUS** 命令显示表的相关信息。例如MySQL库中的user表：

![查看表信息](C:\Users\Administrator\Desktop\截图\查看表信息.PNG)

​	每一行的含义：

- **Name:**

    表名。

- **Engine:**

    表的存储引擎类型。

- **Version:**

    此列未使用。随着MySQL 8.0中.frm文件的删除，本列现在记录一个硬编码值为10，这是MySQL 5.7中使用的最后一个.frm文件版本。

- **Row_format:**

    行的格式（Fixed`,          `Dynamic`, `Compressed`,          `Redundant`, `Compact）。对于MyISAM表，可选的值为Dynamic、Fixed或Compressed。**Dynamic的行长度是可变的**，一般包含可变长度字段，如 **varchar** 或 **blob**。**Fixed的行长度是固定的**，只包含固定长度的列，如 **char** 和 **integer**。 **Compressed的行则只在压缩表中存在（后面会提到MyISAM压缩表）**。

- **Rows:**

    表中的行数。对于 MyISAM 和其他一些存储引擎，该值是精确的，但对于 InnoDB，该值是估计值。

    *For **InnoDB** tables, the row count is only a rough estimate used in SQL optimization. (This is also true if the **InnoDB** table is partitioned.)* 

- **Avg_row_length:**

    平均每行包含的字节数。

- **Data_length:**

    对于 MyISAM，Data_length是数据文件（表数据）的长度（以字节为单位）。

    对于 InnoDB，Data_length是为聚集索引分配的大致空间量（以字节为单位）。具体来说，就是聚集索引的大小乘以 InnoDB 的页面大小。

- **Max_data_length:**

    表数据的最大容量，该值与存储引擎有关（InnoDB未使用）。

- **Index_length:**

    索引的大小（以字节为单位）。

    对于InnoDB，Index_length是为非聚集索引分配的大致空间量（以字节为单位）。具体来说，它是页面中非聚集索引大小乘以InnoDB页面大小的总和。

- **Data_free:**

    对于MyISAM表，表示已分配但目前还没有使用的空间。这部分空间包括了之前删除的行，以及后续可以被 Insert 利用到的空间。

    InnoDB表报告表所属的表空间的空闲空间。对于位于共享表空间中的表，这是共享表空间的空闲空间。如果您使用多个表空间，并且该表有自己的表空间，则空闲空间仅用于该表。空闲空间是指完全空闲区中的字节数减去安全余量。即使空闲空间显示为0，只要不需要分配新的区段，也可以插入行。

    对于其他存储引擎可查看官方文档。

- **Auto_increment:**

    下一个 AUTO_INCREMENT 的值。

- **Create_time:**

    表的创建时间。

- **Update_time:**

    表数据的最后修改时间。

    对于一些存储引擎，该值为null。例如，InnoDB在它的系统表空间中存储了多个表，数据文件的时间戳就不适用了。即使在每个InnoDB表位于单独的 **.ibd** 文件中的**“表文件(file-per-table)”**模式下，更改缓冲也会延迟对数据文件的写入，因此文件修改时间与最后一次插入、更新或删除的时间不同。

    对于MyISAM，使用数据文件时间戳；但是，在Windows上，时间戳不会被更新更新，所以这个值是不准确的。

- **Check_time:**

    使用 **CHECK TABLE** 命令或着 *myisamchk* 工具最后一次检查表的时间。

    对于分区的 InnoDB表来说，该值总是null。

- **Collation:**

    表的默认字符集和字符列排序规则。

- **Checksum:**

    如果启用，保存的是整个表的实时校验和。

- **Create_options:**

    创建表时指定的其他选项。

- **Comment:**

    该列包含一些其他的额外信息。对于MyISAM表，保存的是表在创建时带注释。如果是一个视图，则该列包含 “VIEW“ 的文本字样。

### InnoDB存储引擎（简介）

​	InnoDB 是 MySQL 的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。

#### InnoDB的历史

​	巴拉巴拉~（有空再了解）

#### InnoDB概览

​	InnoDB 的数据存储在表空间（tablespace）中，表空间是由 InnoDB 管理的一个黑盒子，由一系列的数据文件组成。

​	InnoDB 采用 MVCC 来支持高并发，并且支持四个事务隔离级别。默认的级别是 **RR** ，并且通过 **next-key locking** 策略防止幻读的出现。**next-key lock** 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻行的出现。

***next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.*** 

​	InnoDB 表是基于聚簇索引建立的。InnoDB 的索引结构和MySQL的其他存储引擎有很大不同，聚簇索引对主键查询有很高的性能。不过它的二级索引（非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。

​	InnoDB内部做了很多优化，包括**从磁盘读取数据时采用的可预测性预读**，**能够自动在内存中创建hash索引以加速读操作的自适应哈希索引**，以及**能够加速插入操作的插入缓冲区**等。

### MyISAM存储引擎

​	MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但MyISAM 不支持事务和行级锁，且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。虽然 MyISAM 引擎不支持事务、不支持崩溃后的安全恢复，但它对于只读的数据，或者表比较小、可以容忍修复操作，则可以使用 MyISAM。

####  存储

​	MyISAM 会将表存储在两个文件中：**数据文件** 和 **索引文件**，分别以 **.MYD** 和 **.MYI** 为扩展名。 MyISAM 表可以包含动态或者静态（长度固定）行。 MySQL 会根据表的定义来决定采用何种行格式。MyISAM 表可以存储行的记录数（不同与 InnoDB 的估计值，该值为准确值），一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸。

​	在MySQL 5.0 中，MyISAM 表如果是变长行，则默认配合只能处理 256TB 的数据，因为指向数据记录的指针长度为6个字节。要改变 MyISAM 表指针的长度，可以通过修改表的 **MAX_ROWS** 和 **AVG_ROW_LENGTH** 选项的值来实现，两者相乘就是表可能达到的最大大小。修改这两个参数会导致重建整个表和表的所有索引，这可能需要耗费大量时间来完成。

#### MyISAM特性

- **加锁与并发**

    ​	MyISAM的锁策略是**表锁** 。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表插入新的记录（称为并发插入）。

- **修复**

    ​	对于 MyISAM 表，MySQL 可以手工或者自动执行检查和修复操作，这里的修复与事务恢复以及崩溃恢复是不同的概念 。执行表的修复可能会导致一些数据的丢失，且修复操作是非常慢的。可以通过 **CHECK TABLE (TNAME)** 检查表的错误，如果有错误可以通过执行 **REPAIR TABLE (TNAME)** 进行修复。也可以通过 **myisamchk** 命令行工具对已关闭的MySQL服务器进行检查和修复操作。

- **索引特性**

    ​	对于 MyISAM 表，即使是 BLOB 和 TEXT 等 **长字段** ，可以基于前500个字符创建索引。MyISAM 也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。

- **延迟更新索引键**

    ​	创建MyISAM 表的时候，如果指定了 **DELAY_KEY_WRITE** 选项，在每次修改执行完成时，不会like将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种方式极大地提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。延迟更新索引键的特性可以在全局设置，也可以单表设置。

    #### MyISAM压缩表

    ​	如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表或许适合采用 MyISAM 压缩表。

    ​	可以使用 *myisampack* 对 MyISAM 表进行压缩（打包pack）。压缩表是不能进行修改的，除非先将表解压，再修改，再压缩。压缩表可以极大地减少磁盘空间占用，因此也减少了磁盘 I/O，从而提升查询性能。压缩表也支持索引，但索引是只读的。
    
    

### MySQL其他存储引擎

Archive、blackhole、CSV、federated、memory、NDB集群引擎。暂时不学。后面学习后更新。



### 第三方存储引擎

暂置

### 存储引擎的选择

​	在大多数情况下，InnoDB是正确的选择。如果需要用到某些 InnoDB 不具备的特性，则可以考虑其他存储引擎。

​	尽量不要混合使用多种存储引擎，否则可能会带来一系列复杂的问题，以及一些潜在的 Bug 和边界问题。存储引擎层和服务层的交互已经比较复杂，如果在混合多个，可想而知交互会变得更加困难。至少，混合存储对一致性备份和服务器参数配置都来一些困难。

​	我们可以从以下几个因素考虑如何选择存储引擎：

- **事务**

    ​	如果应用需要事务支持，那么 InnoDB 是首选。如果不需要事务，并且主要是 SELECT 和 INSERT 操作，那么 MyISAM 是不错的选择。一般日志型的应用比较符合这一特性。

- **备份**

    ​	备份的需求也是会影响存储引擎选择。如果可以定期关闭服务器进行备份，那么备份的因素可以忽略。反之，如果需要在线备份，InnoDB 又是首选。

- **崩溃恢复**

    ​	崩溃恢复是服务器不得不考虑的问题。当数据量比较大的时候，系统崩溃后如何快速地恢复是关键问题。MyISAM 崩溃后发生损坏的概率要比 InnoDB 高出很多，而且恢复速度也很慢。因此，即使应用不需要事务，大多数人也会选择 InnoDB。

- **特有的特性**

    ​	有些应用可能依赖一些存储引擎所独有的特性或优化，比如很多应用依赖聚簇索引的优化。另外，MySQL中也**只有 MyISAM 支持地理空间搜索** 。在设计应用时，需要某个存储引擎的关键特性，同时该存储引擎又缺乏一些必要的特性，那么这时不得不做折中考虑，或者在架构设计上做一些取舍。

*总的一句话：选 InnoDB！*

#### 日志型应用

​	假设应用需要实时地记录一台中心电话交换机的每一通电话的日志到 MySQL 中，或者通过 Apache 的 **mod_log_sql** 模块将网站的所有访问信息直接记录到表中。这一类应用对插入速度有很高的要求，不能让数据库成为瓶颈。 MyISAM 或者 Archive 存储引擎对这类应用比较合适，因为它们开销低，且插入速度非常快。

​	如果需要对记录的日志作分析报表，那生成的SQL很有可能会影响插入效率，使得插入速度变低。

​	一种解决方法是，利用MySQL内置的复制方案将数据复制一份到备库，然后在备库上执行比较消耗时间和CPU的查询。这样主库只用于高效的插入工作，而备库执行的查询也无需担心影响到日志的插入性能。

​	另一种方案是，在日志记录表的名字中包含年和月的信息，比如 web_log_2020_01，这样可以在已经没有插入操作的历史表上做频繁的查询操作，而不会干扰到最新的当前表上的插入操作（即将同一表的数据按时间分表）。

#### 只读或者大部分情况下只读的表

​	有些表的数据用于编制类目或者分列清单（如工作岗位、竞拍、不动产等），这种应用场景是典型的读多写少的业务。如果不介意 MyISAM 的崩溃恢复问题，则 MyISAM是合适的。但低估崩溃恢复问题带来的教训是沉重的。有些存储引擎不会保证将数据安全地写入到磁盘中。（MyISAM 只将数据写到内存中，等待操作系统定期将数据刷出到磁盘上）。

​	不要轻易相信 “MyISAM 比 InnoDB快” 之类的经验之谈。在很多已知的场景中， InnoDB 的速度往往远超 MyISAM，尤其是使用到聚簇索引，或者需要访问的数据都可以放入内存的应用。

​	当设计上述类型的应用时，建议采用 InnoDB。 MyISAM 引擎在一开始可能没有任何问题，但随着应用压力的上升，则可能迅速恶化。各种锁争用（表锁加大了争用概率）、崩溃后的数据丢失等问题。

#### 订单处理

​	涉及订单处理的应用，那么支持事务就是必要选项。半完成的订单是无法吸引用户的。另外一个重要的考虑点是存储引擎对外键的支持情况。 InnoDB 是订单处理类应用的最佳选择。

#### 电子公告牌和主题讨论论坛

​	主题讨论区一般都有更新计数器，并且会为各个主题计算访问统计信息。多数应用只设计几张表来保存所有数据，所以核心表的读写压力非常大。为保证这些核心表的数据一致性，锁成为资源争用的主要因素。

​	如果Web站点的规模迅速扩展，流量随之猛增，则数据库访问可能变得非常慢。此时一个典型的解决方案就是更改为支持更高读写的存储引擎，但有时用户会发现这么做反而导致系统变得更慢了。

​	这是由于某些特殊查询的缘故，典型的如：

```mysql
mysql> select count(*) from table;
```

​	问题就在于，不是所有的存储引擎运行上述查询都非常快：对于 MyISAM 确实会很快（直接返回表信息中的ROWS字段），但其他的可能都不行。每种存储引擎都能找出类似的对自己有利的例子。

#### CD-ROM应用

​	如果要发布一个基于CD-ROM或这 DVD-ROM并且使用MySQL数据文件的应用，可以考虑使用 MyISAM 或者 MyISQM 压缩表，这样表之间可以隔离并且可以在不同介质上相互拷贝。MyISAM 压缩表比未压缩的表要节约很多空间，但压缩表是只读的。在某些应用中这可能是大问题，但如果数据放到只读介质的场景下，压缩表的只读特性就不是问题。

#### 大数据量

​	要使系统在存储大量数据（3 ~ 5 TB）的情况下还保存良好的运行状态，需要合理的选择硬件，做好物理设计，并为服务器的 I/O 瓶颈做好规划。在大数据量的场景下，如果使用 MyISAM ，崩溃后的恢复就是噩梦。

​	如果数据量继续增长到 10TB 以上级别，可能需要建立数据仓库。 **Infobright** 是 MySQL 数据仓库最成功的解决方案。也有一些大数据库不适合 **Infobright** ，却可能适合 **TokuDB**。 

### 转换表的引擎

​	转换表的存储引擎，将会失去和原引擎相关的所有特性。**如果将一张 InnoDB 的表转换成 MyISAM，然后再转换回 InnoDB，原 InnoDB 表上所有的外键将丢失。**

​	有很多方法可以将表的存储引擎转换成另一种存储引擎，每个方法都有各自的优缺点。在这只讲述以下三种方法：

- **ALTER TABLE**

    该方法是最简单的。下面的语句将 user 表的引擎改为 InnoDB：

    ```mysql
    mysql> ALTER TABLE user ENGINE = InnoDB;
    ```

    ​	上面的语法适用于任何存储引擎。但有一个问题：需要执行很长时间（如何表很大的话）。MySQL 会按行将数据从原表复制到一张新表中，在复制期间可能会消耗系统所有的 I/O 能力，同时原表上会加上读锁。所以，在繁忙的表上执行此操作要特别注意。

- **导入与导出**

    ​	为了更好地控制转换过程，可以使用 *mysqldump* 工具将数据导出到文件，然后修改文件中 **CREATE TABLE** 语句的存储引擎选项，注意同时修改表名，因为同一个数据库不能存在相同的表名，即使是不同存储引擎。同时注意 *mysqldump* 默认会自动在 **CREATE TABLE** 语句前加上 **DROP TABLE** 语句，不注意这一点可能会导致数据丢失。

    ​	该方法是手工进行表复制，意思是将原表的数据导出成文件，再 drop 掉原表，再根据文件修改存储引擎。这样就避免了 **ALTER TABLE** 语句产生的系统消耗和加锁。

- **创建与查询**

    ​	该种转换方法总和了第一种的高效和第二种的安全。不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用 INSERT ... SELECT 语法来导数据：

    ```mysql
    mysql> CREATE TABLE innodb_table LIKE myisam_table;
    mysql> ALTER TABLE innodb_table ENGINE = InnoDB;
    mysql> INSERT INTO innodb_table SELECT * FROM myisam_table;
    ```

    ​	数据量不大的话，这样处理就足够了。如果数据量很大，可以考虑分批处理，针对每一段数据执行事务提交操作，避免长事务产生过多的 **undo** 。假设有主键字段 id，**重复运行**以下语句 （最小值x和最大值y进行响应替换）将数据导入到新表：

    ```mysql
    mysql> STAR TRANSACTION;
    mysql> INSERT INTO innodb_table SELECT * FROM myisam_table 
    	-> WHERE id BETWEEN x AND y;//(这里的意思是分批处理)
    mysql> COMMIT;
    ```

    ​	这样操作完成以后，新表是原表的一个全量复制，原表还在，如果需要可以删除原表。如果有必要，可以在执行过程中对原表进行加锁，以确保新表和原表的数据一直。



## 