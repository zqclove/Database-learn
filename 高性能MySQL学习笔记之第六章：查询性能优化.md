# 查询性能优化

​	查询的优化不仅仅是语句上需要优化，还需要在索引、库表结构上进行优化。三者对性能优化都是不可或缺的。

# 查询慢的原因

​	查询性能与响应时间息息相关。如果我们将查询看作是一个任务，那么它是由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，其实是优化它的子任务，要么减少子任务的执行次数，要么消除子任务，要么让子任务运行的更快。

—— —————————**对于如何剖析查询任务，这里待写，mark一下**。————————————

​	要了解查询慢的原因，可以从查询的生命周期的各个阶段入手，每个阶段可能会有不同的优化手段。

​	执行一个查询时，大多数情况都会产生一些不必要的额外操作、某些操作被额外地重复多次、某些操作执行得太慢等。优化查询的目的就是减少和消除这些操作所花费的时间。

​	由此看来，了解查询的生命周期和清除查询的时间消耗情况对于优化查询有很大的意义。

# 慢查询基础：优化数据访问

​	查询性能低下最基本的原因是**访问数据太多**。对于大部分性能低下的查询可以通过减少访问的数据量进行优化。对于低效的查询，可以通过以下两个步骤分析：

- 确认应用程序是否检索大量超过需要的数据，可能是访问了太多的行或列（应用程序角度）；
- 确认MySQL服务器层是否在分析大量超过需要的数据行（MySQL服务器角度）；

## 避免请求不需要的数据

​	从应用程序角度出发，对于一些查询会请求超过实际需要的数据，而应用程序不需要这些多余的数据，会将之丢弃。这不仅给MySQL服务器带来额外的负担，还会消耗应用程序服务器的CPU和内存资源，甚至在分布式环境下会增加网络开销。

​	以下是应用程序请求不需要的数据的典例：

### 查询不需要的记录

​	开发者在设计应用程序对数据库查询请求代码时，习惯先使用 `select` 语句查询大量的结果，然后再从结果集中获取其中的n行数据（例如某网站从数据取出1000条记录，但真正在页面显示的只有前面10条记录）。这是误认为 MySQL服务器会返回应用程序需要的数据。这种原因的产生一般是发生在应用程序代码层面，是开发者在设计代码时应注意的问题。**最简单有效的解决方法就是在查询后面加上 `limit`**。

### 多表关联时返回全部列

​	如果需要多表关联获取所需的结果，需要在编写查询语句时注意不要按如下写法编写：

```sql
select * from db.table1
inner join db.table2 using(index2)
inner join db.table3 using(index3)
where db.table2.col1 = 'xxxx';
```

​	这会返回table1、table2、table3 三个表的全部数据列。正确的方式应该如下只取需要的列：

```sql
select db.table1.* from ....;
```

​	**在多表关联时使用 select * （返回全部列），应该指定所需数据所在的数据表**。甚至如果没有使用**using**函数作条件的话，会返回全部表笛卡尔积的结果。

### 总是取出全部列

​	对于 **select *** 的写法应该多加留意，是否真正需要取出全部列。取出全部列会让优化器无法完成索引覆盖扫表这类优化，还会给服务器带来额外的IO、内存和CPU消耗。甚至在修改列时，也会带来一些问题。

​	从数据库角度看，取出全部列的确是存在很多性能问题，但从应用程序代码角度上看，取出超过所需数据的量是可以简化开发，提高代码的复用性。因此，开发人员在开发过程中可以采用缓存机制保存这些数据。对于这些问题都是权衡利弊的问题，实际情况实际分析，并不是生搬硬套。

### 重复查询相同的数据

​	多于一些“热点”数据，如果每次请求都去查询数据库，这种重复的查询会加重数据库服务器的负担，增加数据库服务器崩溃的概率。为此，我们可以采用缓存机制，将一些热点数据缓存起来，需要的时候直接从缓存取出，这样不仅性能提高，还减轻了书籍服务器的负担。

### 总结

​	避免请求不需要的数据，是从应用程序代码层面上看待问题，主要是对代码层面的查询请求优化来减轻数据库的负担。一般应用程序代码为了复用性，可以适当的获取超过真正所需要的量，但如果因编写错误导致超出所需要的量时，则需要及时修改。

​	由此看来，避免请求不需要的数据是开发人员在访问数据库时需要注意的点，避免因为失误给数据库增加不必要的负担。

## MySQL是否在扫描额外的记录

​	在应用程序层面确定只返回需要的数据后，就应该从数据库层面分析返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：

- **响应时间**
- **扫描的行数**
- **返回的行数**

​	这三个指标都会记录到MySQL的慢日志中，它们大致的反映了MySQL在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。

### 响应时间

​	响应时间由两部分组成：**服务时间** 和 **等待时间**。服务时间是指在执行查询时真正花费的时间；等待时间是指服务器因为等待某些资源而没有真正执行查询的时间，例如等待IO操作完成、争用锁时的等待，等等。

​	响应时间没有什么公式或规律，而是一种容易受到环境影响的指标，例如存储引擎不同、硬件不同等诸多原因都会影响响应时间。因此，响应时间应该具体情况具体分析，既可能是问题的原因，也可能是问题的结果。

​	对于如何估算响应时间是否是一个合理的值，可以使用**快速上限估计法**，该技术先不作深入，日后研究。

### 扫描的行数和返回的行数

​	一般扫描的行数能够在一定程度上说明查询效率是否高效。返回的行数则是一种结果，是用来判断扫描“命中率”的。

​	在理想情况下，扫描的行数和返回的行数应当是相同的，这样的查询对于MySQL服务器来说近乎完美（命中率极高），但实际情况并非如此。尤其是在关联查询时，服务器必须要扫描多行才能生成一行，扫描的行数和返回的行数的比例通常很小。

​	对一些“糟糕”的查询，该指标可能不够完美，因为行的访问代价不是相同的，较短的行访问速度快、内存中的行比磁盘中的行访问速度快。

### 扫描的行数和访问类型

​	访问类型是指 `EXPLAIN` 表中的 **type**列所反映的结果，即 **join types**。该列的部分值有 **const**（常量）、**eq_ref**（常量引用）、 **ref**（多值引用）、 **rang**（范围扫描）、 **index**（索引扫描）、 **all**（全表扫描）等，速度从快到慢，扫描的行数从大到小。这些访问类型大致可分为扫描表、扫描索引、范围访问和单值访问，即根据访问对象的不同来划分。

​	在对一个查询扫描的行数进行判断时，我们可以根据访问类型大致得出其扫描的范围。比如全表扫描就是扫描整张表，单值访问就是只扫描一个值。而很多扫描行数小的访问类型都与索引有关，比如 **const** 就只发生在主键索引和唯一索引的定值查询中。

​	有了对访问类型的理解，那么对查询优化也有了较简单的方法，比如添加索引、使用覆盖索引（不会回表）等，目的都是为了减少扫描的行数。这里值得一提的是，使用 `where` 关键字和回表的情况，查询在使用 `where` 子句中的条件过滤数据时，可以交给MySQL服务器层过滤，也可交给存储引擎层过滤（索引条件下推），显然是后者的过滤速度更快。还有就是回表的情况，一般发生在二级索引树的查询中，需要到主键索引树获取表数据的过程，这种回表的情况也会有时间消耗和扫描额外的记录。

​	如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试如下技巧去优化：

- 使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了（第五章内容）；
- 改变库表结构。例如使用单独的汇总表（第四章内容）；
- 重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询（下节内容）；

## 总结

​	该章节是对数据访问的查询进行优化。大部分关于数据访问的查询，都是由于请求过多不需要的数据或扫描额外记录而导致查询缓慢。为此，我们可以从两个角度出发，对数据访问的查询进行优化。两个角度分别为：从应用程序（代码）方面，从MySQL服务器方面。

​	在应用层序角度上，设计查询数据的代码，可能会查询比真正需要的数据量还要多的数据，除了需要提高代码复用性外，一般都需要对此进行优化。优化一般可以从 **select *** 入手，这类查询会返回所有列（特别是多表关联时出现的笛卡尔积结果集），是开发人员需要特别注意的，因为可能编写错误或知识不足而使得应用程序关于查询数据的性能低下。

​	在MySQL服务器层面上，一般有三个指标判断查询是否扫描额外的记录：响应时间、扫描的行数、返回的行数。一般通过扫描行数和返回行数就能判断出额外的扫描，但MySQL不会直接给出扫描的行数，而是通过`EXPLAIN` 中的访问类型间接给出。

# 重构查询的方式

​	在重构查询时，大部分都是以分解的思想去优化。在重构查询前，需要判断是否需要将一个复杂查询分成多个简单查询，复杂的查询大概率会让MySQL性能下降，但多个过于简单的查询也会影响效率，不应该生搬硬套。例如一个查询可以获取10行数据，但却将其重构成返回1行数据的查询，并查询10次，这无疑是愚蠢的行为。

​	总的来说，如果一个查询能够优秀地满足查询效率，就不应该再将其分解成多个过于简单的查询。如果一个查询因为过于复杂而导致性能缓慢，就可以考虑分解这个复杂的查询。

​	删除旧数据就是一个分解查询的好例子。在服务器需要删除大量数据时，如果用一个语句一次性删除的话，则大概率一次性锁住很多数据、占满整个事务日志、耗尽系统资源并阻塞大量其他语句。为此，应用程序可以将一个大的 `delete` 语句切分成较小的语句，每隔一段时间执行一次较小的语句，尽可能的将压力分散在不同的时间点上。

​	同样地，对于一些会影响服务器状态的大查询语句，也可以采用切分的方式。

​	在应用程序层面上，我们也可以将关联查询分解成多个单表查询，在应用层做关联。我们可以将单表查询的结果缓存起来，实现可重复利用[^注4.1]。不仅如此，在应用层做关联，还更容易做到提高性能和可扩展。而且MySQL关联查询生成的一行数据可能会重复地访问一部分数据，在应用层做关联查询，则会减少这种额外的消耗。



​	**个人总结**：重构查询的思想主要是分治，将大问题分割成多个小问题。而是否有必要进行重构查询，需要判断大语句是否影响服务器状态、占用过多的资源等因素。对于关联查询，将关联操作上升到应用层，会有很多好处，但也会有坏处。总的来说，重构查询，具体情况具体分析。

[^注4.1]:在应用程序需要查询数据时，如果缓存已有该数据，则可以跳过该查询。这一般是对实时性要求不高、表数据很少改动的查询来说的。如果表数据经常改动，缓存的意义就很微小

# 查询执行的基础

​	当一个客户端需要向MySQL服务器发送一个请求（已连接）时，会做如下基本过程：

1. 客户端根据通信协议发送一条查询给服务器；
2. 服务器检查缓存，如果命中缓存直接返回结果，否则进入下一步；
3. 服务器进行SQL解析、预处理，将处理后的结果交给优化器生成对应的执行计划；
4. 执行器根据执行计划调用存储引擎的API来执行查询生成结果；
5. 将结果返回给客户端，并放入缓存中；

如图所示：



> 需要注意的是，一旦一张表的信息或数据发生变化，那么其在缓存中的结果将会失效。所以一张表如果经常改动，那么将其缓存就没有意义。为此，在MySQL 8.0已经不支持查询缓存了。



# 参考资料

《高性能MySQL》（第三版）——Baron scbwartz等著

[MySQL官网—explain](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)